*** Begin Patch
*** Update File: src/features/diary/screens/DiaryByDayScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  FlatList,
  ScrollView,
  RefreshControl,
  TextInput,
  Alert,
  InteractionManager,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { supabase, supabaseConfig } from "@app/config/supabase.config";
import { ChallengeService, DiaryService } from "@core/services/firestore";
import type { UserProfileLite } from "@core/services/profileCache";
import ProfileCache from "@core/services/profileCache";
import { UserStatsService } from "@core/services/userStatsService";
import DayCard from "@features/diary/components/DayCard";
import Modal from "@shared/components/Modal";
import DiaryCard from "@features/diary/components/DiaryCard";
import { useBlockedIds } from "@shared/state/blockStore";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";
import { colors, spacing, typography } from "@shared/theme";
import { formatDateTimeJP } from "@shared/utils/date";
import { navigateToUserDetail } from "@shared/utils/navigation";

interface DayDiaryItem {
  id: string;
  userId: string;
  content: string;
  createdAt: Date | string | { toDate?: () => Date };
}

// NOTE: Defining row component OUTSIDE the screen component keeps the
// component identity stable across renders and prevents unnecessary
// re-mount/re-render of every row. Previously, defining this inside the
// component recreated the component type on each render, causing churn.
const DiaryItemRow: React.FC<{
  item: DayDiaryItem;
  authorName?: string;
  authorAvatar?: string;
  averageDays: number;
  onAuthorPress: (uid: string, uname?: string) => void;
}> = React.memo(
  ({ item, authorName, authorAvatar, averageDays, onAuthorPress }) => (
    <View style={{ marginBottom: spacing.sm }}>
      <DiaryCard
        authorId={item.userId}
        authorName={authorName ?? 'ユーザー'}
        authorAvatar={authorAvatar}
        averageDays={averageDays}
        content={item.content}
        createdAt={item.createdAt}
        onAuthorPress={() => onAuthorPress(item.userId, authorName)}
      />
    </View>
  ),
  (prev, next) =>
    prev.item.id === next.item.id &&
    prev.item.content === next.item.content &&
    String(prev.item.createdAt) === String(next.item.createdAt) &&
    prev.authorName === next.authorName &&
    prev.authorAvatar === next.authorAvatar &&
    prev.averageDays === next.averageDays,
);

const DiaryByDayScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [day, setDay] = useState<number>(1);
  const [items, setItems] = useState<DayDiaryItem[]>([]);
  const [userAverageDays, setUserAverageDays] = useState<Map<string, number>>(
    new Map(),
  );
  const [loading, setLoading] = useState<boolean>(false);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const blockedSet = useBlockedIds();
  const { requireAuth } = useAuthPrompt();
  const [showAdd, setShowAdd] = useState<boolean>(false);
  const [addText, setAddText] = useState<string>("");
  const [activeDay, setActiveDay] = useState<number | null>(null);
  const [alreadyPosted, setAlreadyPosted] = useState<boolean>(false);

  useEffect(() => {
    void (async () => {
      if (user?.uid) {
        const active = await ChallengeService.getActiveChallenge(user.uid);
        if (active) {
          const startedAt =
            (active.startedAt as any)?.toDate?.() || (active.startedAt as any);
          const now = new Date();
          const d =
            Math.floor(
              (now.getTime() - startedAt.getTime()) / (24 * 3600 * 1000),
            ) + 1;
          if (d > 0) {
            setDay(d);
            setActiveDay(d);
          }
        } else {
          setActiveDay(null);
        }
      }
    })();
  }, [user?.uid]);

  // blockedSet subscription is global; no need for Firestore here

  useEffect(() => {
    const fetch = async () => {
      setLoading(true);
      try {
        const list = await DiaryService.getDiariesByDay(day, 200);
        const mapped = list
          .map((d) => ({
            id: d.id,
            userId: (d as any).userId,
            content: d.content,
            createdAt: (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
          }))
          .filter((it) => !blockedSet.has(it.userId));
        setItems(mapped);
        // ユーザー名・アバターは各行コンポーネント側でライブ解決（useDisplayProfile）
        // prefetch averageDays for ranks (bulk)
        try {
          const ids = Array.from(new Set(mapped.map((m) => m.userId)));
          const next = new Map(userAverageDays);
          const missing = ids.filter((uid) => !next.has(uid));
          if (missing.length > 0) {
            const map = await UserStatsService.getManyUsersCurrentDaysForRank(missing);
            map.forEach((days, uid) => next.set(uid, Math.max(0, days)));
          }
          setUserAverageDays(next);
        } catch { }
      } finally {
        setLoading(false);
      }
    };
    const task = InteractionManager.runAfterInteractions(() => {
      void fetch();
    });
    return () => {
      try { (task as any)?.cancel?.(); } catch { }
    };
  }, [day, blockedSet]);

  // 選択中の「日」のみRealtime購読して差分適用（負荷抑制）
  useEffect(() => {
    if (!supabaseConfig?.isConfigured) return;
    let active = true;
    const channel = supabase
      .channel(`realtime:diaries:day:${day}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "diaries", filter: `day=eq.${day}` },
        (payload) => {
          const row = (payload.new || payload.old) as any;
          if (!row) return;
          // 受信データを画面の型に合わせる
          const mapped = {
            id: row.id as string,
            userId: row.userId as string,
            content: row.content as string,
            createdAt:
              (row.createdAt as any)?.toDate?.() ||
              (typeof row.createdAt === "string" ? new Date(row.createdAt) : row.createdAt),
          } as DayDiaryItem;

          setItems((prev) => {
            let next = prev;
            // ブロックユーザーの項目は表示しない
            const visible = !blockedSet.has(mapped.userId);

            if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
              // 既存を置換 or 先頭に追加
              const idx = next.findIndex((it) => it.id === mapped.id);
              if (!visible) {
                // 可視条件を満たさない場合は削除扱い
                if (idx !== -1) {
                  next = [...next.slice(0, idx), ...next.slice(idx + 1)];
                }
                return next;
              }
              if (idx === -1) {
                next = [mapped, ...next];
              } else {
                next = [...next];
                next[idx] = mapped;
              }
              // createdAt 降順を維持
              next = next.slice().sort((a, b) => (new Date(b.createdAt as any).getTime() - new Date(a.createdAt as any).getTime()));
              return next;
            }
            if (payload.eventType === "DELETE") {
              const idx = next.findIndex((it) => it.id === mapped.id);
              if (idx !== -1) {
                next = [...next.slice(0, idx), ...next.slice(idx + 1)];
              }
              return next;
            }
            return next;
          });
        },
      );

    channel.subscribe();

    return () => {
      active = false;
      try { supabase.removeChannel(channel); } catch { }
    };
  }, [day, blockedSet]);

  // プロフィール購読は各行に委譲（画面側では保持しない）

  // Check if user already posted for the selected day (only matters on active day)
  useEffect(() => {
    void (async () => {
      if (!user?.uid || activeDay === null || day !== activeDay) {
        setAlreadyPosted(false);
        return;
      }
      try {
        const exists = await DiaryService.hasDiaryForActiveChallengeDay(
          user.uid,
          day,
        );
        setAlreadyPosted(exists);
      } catch {
        setAlreadyPosted(false);
      }
    })();
  }, [user?.uid, day, activeDay]);

  const onRefresh = async () => {
    setRefreshing(true);
    try {
      const list = await DiaryService.getDiariesByDay(day, 200);
      const mapped = list
        .map((d) => ({
          id: d.id,
          userId: (d as any).userId,
          content: d.content,
          createdAt: (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
        }))
        .filter((it) => !blockedSet.has(it.userId));
      setItems(mapped);
      try {
        const ids = Array.from(new Set(mapped.map((m) => m.userId)));
        const next = new Map(userAverageDays);
        const missing = ids.filter((uid) => !next.has(uid));
        if (missing.length > 0) {
          const map = await UserStatsService.getManyUsersCurrentDaysForRank(missing);
          map.forEach((days, uid) => next.set(uid, Math.max(0, days)));
        }
        setUserAverageDays(next);
      } catch { }
    } finally {
      setRefreshing(false);
    }
  };

  // day selection is controlled via card taps; chevron selector removed

  const renderItem = React.useCallback(
    ({ item }: { item: DayDiaryItem }) => {
      const avgDays = userAverageDays.get(item.userId) ?? 0;
      return (
        <DiaryItemRow
          item={item}
          authorName={undefined}
          authorAvatar={undefined}
          averageDays={avgDays}
          onAuthorPress={(uid, uname) =>
            navigateToUserDetail(
              navigation as any,
              uid,
              uname ?? undefined,
              undefined,
            )
          }
        />
      );
    },
    [userAverageDays, navigation],
  );

  const canPostForSelectedDay =
    activeDay !== null && day === activeDay && !alreadyPosted;
  const postDisabledReason =
    activeDay === null
      ? "アクティブなチャレンジがありません"
      : day !== activeDay
        ? "日記は現在のチャレンジ日（当日）のみ投稿できます。"
        : alreadyPosted
          ? "本日は既に投稿済みです。明日また書きましょう。"
          : "";

  // days data for horizontal day selector (virtualized)
  const daysData = useMemo(() => Array.from({ length: 365 }, (_, i) => i + 1), []);
  const dayListRef = useRef<FlatList<number>>(null);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.iconBtn}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.title}>みんなの日記</Text>
        <TouchableOpacity
          onPress={async () => {
            const ok = await requireAuth();
            if (!ok) return;
            if (!canPostForSelectedDay) {
              Alert.alert("投稿できません", postDisabledReason);
              return;
            }
            setAddText("");
            setShowAdd(true);
          }}
          style={styles.iconBtn}
        >
          <Ionicons
            name="create-outline"
            size={22}
            color={canPostForSelectedDay ? colors.primary : colors.gray400}
          />
        </TouchableOpacity>
      </View>

      <FlatList
        data={items}
        keyExtractor={(i) => i.id}
        renderItem={renderItem}
        contentContainerStyle={{ padding: spacing.lg }}
        initialNumToRender={8}
        windowSize={7}
        maxToRenderPerBatch={12}
        removeClippedSubviews
        ListEmptyComponent={
          <View style={{ alignItems: "center", padding: spacing.lg }}>
            <Ionicons
              name={loading ? "time-outline" : "book-outline"}
              size={48}
              color={colors.textSecondary}
            />
            <Text
              style={{ color: colors.textSecondary, marginTop: spacing.sm }}
            >
              {loading ? "読み込み中..." : "この日の記録はまだありません"}
            </Text>
          </View>
        }
        ListHeaderComponent={
          <View>
            <FlatList
              ref={dayListRef}
              data={daysData}
              keyExtractor={(d) => String(d)}
              horizontal
              showsHorizontalScrollIndicator={false}
              renderItem={({ item: d }) => (
                <DayCard
                  day={d}
                  selected={d === day}
                  posted={activeDay !== null && d === activeDay && alreadyPosted}
                  onPress={(sel) => setDay(sel)}
                />
              )}
              contentContainerStyle={styles.cardsRow}
              initialNumToRender={24}
              windowSize={5}
              maxToRenderPerBatch={24}
              removeClippedSubviews
            />
            <Text style={styles.helperText}>
              {activeDay === null && "チャレンジを開始すると日記を投稿できます"}
              {activeDay !== null &&
                day !== activeDay &&
                "日記は当日分のみ投稿できます"}
              {activeDay !== null &&
                day === activeDay &&
                alreadyPosted &&
                "本日は投稿済みです。明日また書きましょう"}
              {activeDay !== null &&
                day === activeDay &&
                !alreadyPosted &&
                "今日の日記を投稿しましょう"}
            </Text>
          </View>
        }
        stickyHeaderIndices={[0]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor={colors.primary}
          />
        }
      />

      <TouchableOpacity
        style={[
          styles.fab,
          !canPostForSelectedDay && { backgroundColor: colors.gray300 },
        ]}
        onPress={() => {
          if (!canPostForSelectedDay) {
            Alert.alert("投稿できません", postDisabledReason);
            return;
          }
          setAddText("");
          setShowAdd(true);
        }}
      >
        <Ionicons name="create-outline" size={22} color={colors.white} />
      </TouchableOpacity>

      <Modal
        visible={showAdd}
        onClose={() => setShowAdd(false)}
        title={`${day}日目に追加`}
      >
        <View>
          <TextInput
            placeholder="いまの気付きや変化を書きましょう"
            placeholderTextColor={colors.textSecondary}
            value={addText}
            onChangeText={setAddText}
            multiline
            autoFocus
            style={styles.modalInput}
          />
          <View style={styles.modalButtons}>
            <TouchableOpacity
              onPress={() => setShowAdd(false)}
              style={styles.modalCancel}
            >
              <Text style={styles.modalCancelText}>キャンセル</Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={async () => {
                const ok = await requireAuth();
                if (!ok) return;
                if (!user?.uid || !addText.trim()) return;
                try {
                  await DiaryService.addDiaryForActiveChallenge(
                    user.uid,
                    addText.trim(),
                    { day },
                  );

                  // 日記追加成功後の処理
                  setShowAdd(false);
                  setAddText("");

                  // 現在の日のリストをリフレッシュ
                  try {
                    const list = await DiaryService.getDiariesByDay(day, 200);
                    const mapped = list.map((d) => ({
                      id: d.id,
                      userId: (d as any).userId,
                      content: d.content,
                      createdAt:
                        (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
                    }));
                    setItems(mapped);
                    if (activeDay !== null && day === activeDay)
                      setAlreadyPosted(true);
                  } catch (refreshError) {
                    console.warn("日記リストのリフレッシュに失敗しました:", refreshError);
                  }
                } catch (e: any) {
                  Alert.alert(
                    "投稿できません",
                    e?.message || "条件を満たしていません。",
                  );
                  return;
                }
              }}
              style={[
                styles.modalSubmit,
                (!addText.trim() || !canPostForSelectedDay) &&
                styles.modalSubmitDisabled,
              ]}
              disabled={!addText.trim() || !canPostForSelectedDay}
            >
              <Text style={styles.modalSubmitText}>追加</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: colors.backgroundTertiary },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  iconBtn: { padding: spacing.sm },
  title: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  daySelector: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  dayBtn: { paddingHorizontal: spacing.lg, paddingVertical: spacing.xs },
  dayText: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.textPrimary,
  },
  // card-related styles removed; use DiaryCard component for consistent look with posts
  cardsRow: { paddingHorizontal: spacing.lg, paddingBottom: spacing.sm },
  fab: {
    position: "absolute",
    right: spacing.lg,
    bottom: spacing.lg,
    backgroundColor: colors.primary,
    width: 56,
    height: 56,
    borderRadius: 28,
    alignItems: "center",
    justifyContent: "center",
  },
  modalInput: {
    minHeight: 140,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 12,
    padding: spacing.md,
    color: colors.textPrimary,
    textAlignVertical: "top",
    backgroundColor: colors.white,
  },
  modalButtons: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    marginTop: spacing.md,
    gap: spacing.md,
  },
  modalCancel: { paddingHorizontal: spacing.md, paddingVertical: spacing.xs },
  modalCancelText: { color: colors.textSecondary },
  modalSubmit: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
  },
  modalSubmitDisabled: { backgroundColor: colors.gray300 },
  modalSubmitText: { color: colors.white, fontWeight: "600" },
  helperText: {
    color: colors.textSecondary,
    paddingHorizontal: spacing.lg,
    paddingBottom: spacing.md,
  },
});

export default DiaryByDayScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  FlatList,
  ScrollView,
  RefreshControl,
  TextInput,
  Alert,
  InteractionManager,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { supabase, supabaseConfig } from "@app/config/supabase.config";
import { ChallengeService, DiaryService } from "@core/services/firestore";
import type { UserProfileLite } from "@core/services/profileCache";
import ProfileCache from "@core/services/profileCache";
import { UserStatsService } from "@core/services/userStatsService";
import DayCard from "@features/diary/components/DayCard";
import Modal from "@shared/components/Modal";
import DiaryCard from "@features/diary/components/DiaryCard";
import { useBlockedIds } from "@shared/state/blockStore";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";
import { colors, spacing, typography } from "@shared/theme";
import { formatDateTimeJP } from "@shared/utils/date";
import { navigateToUserDetail } from "@shared/utils/navigation";

interface DayDiaryItem {
  id: string;
  userId: string;
  content: string;
  createdAt: Date | string | { toDate?: () => Date };
}

// NOTE: Defining row component OUTSIDE the screen component keeps the
// component identity stable across renders and prevents unnecessary
// re-mount/re-render of every row. Previously, defining this inside the
// component recreated the component type on each render, causing churn.
const DiaryItemRow: React.FC<{
  item: DayDiaryItem;
  authorName?: string;
  authorAvatar?: string;
  averageDays: number;
  onAuthorPress: (uid: string, uname?: string) => void;
}> = React.memo(
  ({ item, authorName, authorAvatar, averageDays, onAuthorPress }) => (
    <View style={{ marginBottom: spacing.sm }}>
      <DiaryCard
        authorId={item.userId}
        authorName={authorName ?? 'ユーザー'}
        authorAvatar={authorAvatar}
        averageDays={averageDays}
        content={item.content}
        createdAt={item.createdAt}
        onAuthorPress={() => onAuthorPress(item.userId, authorName)}
      />
    </View>
  ),
  (prev, next) =>
    prev.item.id === next.item.id &&
    prev.item.content === next.item.content &&
    String(prev.item.createdAt) === String(next.item.createdAt) &&
    prev.authorName === next.authorName &&
    prev.authorAvatar === next.authorAvatar &&
    prev.averageDays === next.averageDays,
);

const DiaryByDayScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [day, setDay] = useState<number>(1);
  const [items, setItems] = useState<DayDiaryItem[]>([]);
  const [userAverageDays, setUserAverageDays] = useState<Map<string, number>>(
    new Map(),
  );
  const [loading, setLoading] = useState<boolean>(false);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const blockedSet = useBlockedIds();
  const { requireAuth } = useAuthPrompt();
  const [showAdd, setShowAdd] = useState<boolean>(false);
  const [addText, setAddText] = useState<string>("");
  const [activeDay, setActiveDay] = useState<number | null>(null);
  const [alreadyPosted, setAlreadyPosted] = useState<boolean>(false);

  useEffect(() => {
    void (async () => {
      if (user?.uid) {
        const active = await ChallengeService.getActiveChallenge(user.uid);
        if (active) {
          const startedAt =
            (active.startedAt as any)?.toDate?.() || (active.startedAt as any);
          const now = new Date();
          const d =
            Math.floor(
              (now.getTime() - startedAt.getTime()) / (24 * 3600 * 1000),
            ) + 1;
          if (d > 0) {
            setDay(d);
            setActiveDay(d);
          }
        } else {
          setActiveDay(null);
        }
      }
    })();
  }, [user?.uid]);

  // blockedSet subscription is global; no need for Firestore here

  useEffect(() => {
    const fetch = async () => {
      setLoading(true);
      try {
        const list = await DiaryService.getDiariesByDay(day, 200);
        const mapped = list
          .map((d) => ({
            id: d.id,
            userId: (d as any).userId,
            content: d.content,
            createdAt: (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
          }))
          .filter((it) => !blockedSet.has(it.userId));
        setItems(mapped);
        // ユーザー名・アバターは各行コンポーネント側でライブ解決（useDisplayProfile）
        // prefetch averageDays for ranks (bulk)
        try {
          const ids = Array.from(new Set(mapped.map((m) => m.userId)));
          const next = new Map(userAverageDays);
          const missing = ids.filter((uid) => !next.has(uid));
          if (missing.length > 0) {
            const map = await UserStatsService.getManyUsersCurrentDaysForRank(missing);
            map.forEach((days, uid) => next.set(uid, Math.max(0, days)));
          }
          setUserAverageDays(next);
        } catch { }
      } finally {
        setLoading(false);
      }
    };
    const task = InteractionManager.runAfterInteractions(() => {
      void fetch();
    });
    return () => {
      try { (task as any)?.cancel?.(); } catch { }
    };
  }, [day, blockedSet]);

  // 選択中の「日」のみRealtime購読して差分適用（負荷抑制）
  useEffect(() => {
    if (!supabaseConfig?.isConfigured) return;
    let active = true;
    const channel = supabase
      .channel(`realtime:diaries:day:${day}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "diaries", filter: `day=eq.${day}` },
        (payload) => {
          const row = (payload.new || payload.old) as any;
          if (!row) return;
          // 受信データを画面の型に合わせる
          const mapped = {
            id: row.id as string,
            userId: row.userId as string,
            content: row.content as string,
            createdAt:
              (row.createdAt as any)?.toDate?.() ||
              (typeof row.createdAt === "string" ? new Date(row.createdAt) : row.createdAt),
          } as DayDiaryItem;

          setItems((prev) => {
            let next = prev;
            // ブロックユーザーの項目は表示しない
            const visible = !blockedSet.has(mapped.userId);

            if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
              // 既存を置換 or 先頭に追加
              const idx = next.findIndex((it) => it.id === mapped.id);
              if (!visible) {
                // 可視条件を満たさない場合は削除扱い
                if (idx !== -1) {
                  next = [...next.slice(0, idx), ...next.slice(idx + 1)];
                }
                return next;
              }
              if (idx === -1) {
                next = [mapped, ...next];
              } else {
                next = [...next];
                next[idx] = mapped;
              }
              // createdAt 降順を維持
              next = next.slice().sort((a, b) => (new Date(b.createdAt as any).getTime() - new Date(a.createdAt as any).getTime()));
              return next;
            }
            if (payload.eventType === "DELETE") {
              const idx = next.findIndex((it) => it.id === mapped.id);
              if (idx !== -1) {
                next = [...next.slice(0, idx), ...next.slice(idx + 1)];
              }
              return next;
            }
            return next;
          });
        },
      );

    channel.subscribe();

    return () => {
      active = false;
      try { supabase.removeChannel(channel); } catch { }
    };
  }, [day, blockedSet]);

  // プロフィール購読は各行に委譲（画面側では保持しない）

  // Check if user already posted for the selected day (only matters on active day)
  useEffect(() => {
    void (async () => {
      if (!user?.uid || activeDay === null || day !== activeDay) {
        setAlreadyPosted(false);
        return;
      }
      try {
        const exists = await DiaryService.hasDiaryForActiveChallengeDay(
          user.uid,
          day,
        );
        setAlreadyPosted(exists);
      } catch {
        setAlreadyPosted(false);
      }
    })();
  }, [user?.uid, day, activeDay]);

  const onRefresh = async () => {
    setRefreshing(true);
    try {
      const list = await DiaryService.getDiariesByDay(day, 200);
      const mapped = list
        .map((d) => ({
          id: d.id,
          userId: (d as any).userId,
          content: d.content,
          createdAt: (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
        }))
        .filter((it) => !blockedSet.has(it.userId));
      setItems(mapped);
      try {
        const ids = Array.from(new Set(mapped.map((m) => m.userId)));
        const next = new Map(userAverageDays);
        const missing = ids.filter((uid) => !next.has(uid));
        if (missing.length > 0) {
          const map = await UserStatsService.getManyUsersCurrentDaysForRank(missing);
          map.forEach((days, uid) => next.set(uid, Math.max(0, days)));
        }
        setUserAverageDays(next);
      } catch { }
    } finally {
      setRefreshing(false);
    }
  };

  // day selection is controlled via card taps; chevron selector removed

  const renderItem = React.useCallback(
    ({ item }: { item: DayDiaryItem }) => {
      const avgDays = userAverageDays.get(item.userId) ?? 0;
      return (
        <DiaryItemRow
          item={item}
          authorName={undefined}
          authorAvatar={undefined}
          averageDays={avgDays}
          onAuthorPress={(uid, uname) =>
            navigateToUserDetail(
              navigation as any,
              uid,
              uname ?? undefined,
              undefined,
            )
          }
        />
      );
    },
    [userAverageDays, navigation],
  );

  const canPostForSelectedDay =
    activeDay !== null && day === activeDay && !alreadyPosted;
  const postDisabledReason =
    activeDay === null
      ? "アクティブなチャレンジがありません"
      : day !== activeDay
        ? "日記は現在のチャレンジ日（当日）のみ投稿できます。"
        : alreadyPosted
          ? "本日は既に投稿済みです。明日また書きましょう。"
          : "";

  // days data for horizontal day selector (virtualized)
  const daysData = useMemo(() => Array.from({ length: 365 }, (_, i) => i + 1), []);
  const dayListRef = useRef<FlatList<number>>(null);

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.iconBtn}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.title}>みんなの日記</Text>
        <TouchableOpacity
          onPress={async () => {
            const ok = await requireAuth();
            if (!ok) return;
            if (!canPostForSelectedDay) {
              Alert.alert("投稿できません", postDisabledReason);
              return;
            }
            setAddText("");
            setShowAdd(true);
          }}
          style={styles.iconBtn}
        >
          <Ionicons
            name="create-outline"
            size={22}
            color={canPostForSelectedDay ? colors.primary : colors.gray400}
          />
        </TouchableOpacity>
      </View>

      <FlatList
        data={items}
        keyExtractor={(i) => i.id}
        renderItem={renderItem}
        contentContainerStyle={{ padding: spacing.lg }}
        initialNumToRender={8}
        windowSize={7}
        maxToRenderPerBatch={12}
        removeClippedSubviews
        ListEmptyComponent={
          <View style={{ alignItems: "center", padding: spacing.lg }}>
            <Ionicons
              name={loading ? "time-outline" : "book-outline"}
              size={48}
              color={colors.textSecondary}
            />
            <Text
              style={{ color: colors.textSecondary, marginTop: spacing.sm }}
            >
              {loading ? "読み込み中..." : "この日の記録はまだありません"}
            </Text>
          </View>
        }
        ListHeaderComponent={
          <View>
            <FlatList
              ref={dayListRef}
              data={daysData}
              keyExtractor={(d) => String(d)}
              horizontal
              showsHorizontalScrollIndicator={false}
              renderItem={({ item: d }) => (
                <DayCard
                  day={d}
                  selected={d === day}
                  posted={activeDay !== null && d === activeDay && alreadyPosted}
                  onPress={(sel) => setDay(sel)}
                />
              )}
              contentContainerStyle={styles.cardsRow}
              initialNumToRender={24}
              windowSize={5}
              maxToRenderPerBatch={24}
              removeClippedSubviews
            />
            <Text style={styles.helperText}>
              {activeDay === null && "チャレンジを開始すると日記を投稿できます"}
              {activeDay !== null &&
                day !== activeDay &&
                "日記は当日分のみ投稿できます"}
              {activeDay !== null &&
                day === activeDay &&
                alreadyPosted &&
                "本日は投稿済みです。明日また書きましょう"}
              {activeDay !== null &&
                day === activeDay &&
                !alreadyPosted &&
                "今日の日記を投稿しましょう"}
            </Text>
          </View>
        }
        stickyHeaderIndices={[0]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor={colors.primary}
          />
        }
      />

      <TouchableOpacity
        style={[
          styles.fab,
          !canPostForSelectedDay && { backgroundColor: colors.gray300 },
        ]}
        onPress={() => {
          if (!canPostForSelectedDay) {
            Alert.alert("投稿できません", postDisabledReason);
            return;
          }
          setAddText("");
          setShowAdd(true);
        }}
      >
        <Ionicons name="create-outline" size={22} color={colors.white} />
      </TouchableOpacity>

      <Modal
        visible={showAdd}
        onClose={() => setShowAdd(false)}
        title={`${day}日目に追加`}
      >
        <View>
          <TextInput
            placeholder="いまの気付きや変化を書きましょう"
            placeholderTextColor={colors.textSecondary}
            value={addText}
            onChangeText={setAddText}
            multiline
            autoFocus
            style={styles.modalInput}
          />
          <View style={styles.modalButtons}>
            <TouchableOpacity
              onPress={() => setShowAdd(false)}
              style={styles.modalCancel}
            >
              <Text style={styles.modalCancelText}>キャンセル</Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={async () => {
                const ok = await requireAuth();
                if (!ok) return;
                if (!user?.uid || !addText.trim()) return;
                try {
                  await DiaryService.addDiaryForActiveChallenge(
                    user.uid,
                    addText.trim(),
                    { day },
                  );

                  // 日記追加成功後の処理
                  setShowAdd(false);
                  setAddText("");

                  // 現在の日のリストをリフレッシュ
                  try {
                    const list = await DiaryService.getDiariesByDay(day, 200);
                    const mapped = list.map((d) => ({
                      id: d.id,
                      userId: (d as any).userId,
                      content: d.content,
                      createdAt:
                        (d.createdAt as any)?.toDate?.() || (d.createdAt as any),
                    }));
                    setItems(mapped);
                    if (activeDay !== null && day === activeDay)
                      setAlreadyPosted(true);
                  } catch (refreshError) {
                    console.warn("日記リストのリフレッシュに失敗しました:", refreshError);
                  }
                } catch (e: any) {
                  Alert.alert(
                    "投稿できません",
                    e?.message || "条件を満たしていません。",
                  );
                  return;
                }
              }}
              style={[
                styles.modalSubmit,
                (!addText.trim() || !canPostForSelectedDay) &&
                styles.modalSubmitDisabled,
              ]}
              disabled={!addText.trim() || !canPostForSelectedDay}
            >
              <Text style={styles.modalSubmitText}>追加</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: colors.backgroundTertiary },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  iconBtn: { padding: spacing.sm },
  title: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  daySelector: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  dayBtn: { paddingHorizontal: spacing.lg, paddingVertical: spacing.xs },
  dayText: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.textPrimary,
  },
  // card-related styles removed; use DiaryCard component for consistent look with posts
  cardsRow: { paddingHorizontal: spacing.lg, paddingBottom: spacing.sm },
  fab: {
    position: "absolute",
    right: spacing.lg,
    bottom: spacing.lg,
    backgroundColor: colors.primary,
    width: 56,
    height: 56,
    borderRadius: 28,
    alignItems: "center",
    justifyContent: "center",
  },
  modalInput: {
    minHeight: 140,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 12,
    padding: spacing.md,
    color: colors.textPrimary,
    textAlignVertical: "top",
    backgroundColor: colors.white,
  },
  modalButtons: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    marginTop: spacing.md,
    gap: spacing.md,
  },
  modalCancel: { paddingHorizontal: spacing.md, paddingVertical: spacing.xs },
  modalCancelText: { color: colors.textSecondary },
  modalSubmit: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
  },
  modalSubmitDisabled: { backgroundColor: colors.gray300 },
  modalSubmitText: { color: colors.white, fontWeight: "600" },
  helperText: {
    color: colors.textSecondary,
    paddingHorizontal: spacing.lg,
    paddingBottom: spacing.md,
  },
});

export default DiaryByDayScreen;

*** Update File: src/features/e2e/screens/E2EScreen.tsx
@@
-import React from 'react';
import { SafeAreaView, StatusBar } from 'react-native';
import TimerScreen from '@features/challenge/screens/TimerScreen';
import { colors } from '@shared/theme';

const E2EScreen: React.FC = () => {
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colors.backgroundTertiary }}>
      <StatusBar barStyle="dark-content" backgroundColor={colors.backgroundTertiary} />
      <TimerScreen />
    </SafeAreaView>
  );
};

export default E2EScreen;


+import React from 'react';
import { SafeAreaView, StatusBar } from 'react-native';
import TimerScreen from '@features/challenge/screens/TimerScreen';
import { colors } from '@shared/theme';

const E2EScreen: React.FC = () => {
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colors.backgroundTertiary }}>
      <AppStatusBar />
      <TimerScreen />
    </SafeAreaView>
  );
};

export default E2EScreen;


*** Update File: src/features/home/screens/HomeScreen.tsx
@@
-import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useCallback, useState } from "react";
import { SafeAreaView, StatusBar, StyleSheet, View } from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import TimerScreen from "@features/challenge/screens/TimerScreen";
import DiaryButton from "@features/diary/components/DiaryButton";
import HistoryButton from "@features/home/components/HistoryButton";
import RankingButton from "@features/home/components/RankingButton";
import { colors, spacing } from "@shared/theme";

// プロフィール初期設定モーダルの自動表示は廃止

type HomeNav = StackNavigationProp<RootStackParamList>;

type HomeScreenProps = {
  navigation: HomeNav;
};

const HomeScreen: React.FC<HomeScreenProps> = ({ navigation }) => {
  const { user } = useAuth();
  const [refreshKey, setRefreshKey] = useState(0);


  const refreshHomeScreen = useCallback(() => {
    setRefreshKey(prev => prev + 1);
  }, []);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />
      <TimerScreen
        key={refreshKey}
        onChallengeStarted={refreshHomeScreen}
      />

      <View style={styles.buttonContainer}>
        <View style={styles.quickBtn}>
          <HistoryButton onPress={() => navigation.navigate("History")} />
        </View>
        <View style={styles.quickBtn}>
          <DiaryButton onPress={() => navigation.navigate("Diary")} />
        </View>
        <View style={styles.quickBtn}>
          <RankingButton
            onPress={() => navigation.navigate("Ranking")}
            style={{ width: "100%" }}
          />
        </View>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 0,
    paddingBottom: spacing.lg,
  },
  quickBtn: {
    flex: 1,
    minWidth: 120,
    alignItems: "stretch",
    paddingHorizontal: spacing.xs,
  },
});

export default HomeScreen;

+import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useCallback, useState } from "react";
import { SafeAreaView, StatusBar, StyleSheet, View } from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import TimerScreen from "@features/challenge/screens/TimerScreen";
import DiaryButton from "@features/diary/components/DiaryButton";
import HistoryButton from "@features/home/components/HistoryButton";
import RankingButton from "@features/home/components/RankingButton";
import { colors, spacing } from "@shared/theme";

// プロフィール初期設定モーダルの自動表示は廃止

type HomeNav = StackNavigationProp<RootStackParamList>;

type HomeScreenProps = {
  navigation: HomeNav;
};

const HomeScreen: React.FC<HomeScreenProps> = ({ navigation }) => {
  const { user } = useAuth();
  const [refreshKey, setRefreshKey] = useState(0);


  const refreshHomeScreen = useCallback(() => {
    setRefreshKey(prev => prev + 1);
  }, []);

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />
      <TimerScreen
        key={refreshKey}
        onChallengeStarted={refreshHomeScreen}
      />

      <View style={styles.buttonContainer}>
        <View style={styles.quickBtn}>
          <HistoryButton onPress={() => navigation.navigate("History")} />
        </View>
        <View style={styles.quickBtn}>
          <DiaryButton onPress={() => navigation.navigate("Diary")} />
        </View>
        <View style={styles.quickBtn}>
          <RankingButton
            onPress={() => navigation.navigate("Ranking")}
            style={{ width: "100%" }}
          />
        </View>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 0,
    paddingBottom: spacing.lg,
  },
  quickBtn: {
    flex: 1,
    minWidth: 120,
    alignItems: "stretch",
    paddingHorizontal: spacing.xs,
  },
});

export default HomeScreen;

*** Update File: src/features/history/screens/HistoryScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation, useFocusEffect } from "@react-navigation/native";
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  ScrollView,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { ChallengeService, PaymentFirestoreService } from "@core/services/firestore";
import { StatsService } from "@core/services/statsService";
import HistoryCard from "@features/history/components/HistoryCard";
import type { Challenge, Payment } from "@project-types";
import { colors, spacing, typography } from "@shared/theme";
import { screenThemes } from "@shared/theme/screenThemes";

const HistoryScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [challenges, setChallenges] = useState<Challenge[]>([]);
  const [payments, setPayments] = useState<Payment[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  // 進行中の時間表示は各カード側で処理するため、画面全体の毎秒再レンダは不要

  // Firestoreからデータを取得
  useEffect(() => {
    const fetchData = async () => {
      if (!user?.uid) {
        return;
      }

      try {
        // チャレンジ履歴を取得
        const firestoreChallenges = await ChallengeService.getUserChallenges(
          user.uid,
        );
        const challengesData = firestoreChallenges.map((challenge) => ({
          id: challenge.id,
          userId: challenge.userId,
          goalDays: challenge.goalDays,
          penaltyAmount: challenge.penaltyAmount,
          status: challenge.status,
          startedAt:
            challenge.startedAt instanceof Date
              ? challenge.startedAt
              : new Date(challenge.startedAt as any),
          completedAt:
            challenge.completedAt instanceof Date
              ? challenge.completedAt
              : challenge.completedAt
                ? new Date(challenge.completedAt as any)
                : undefined,
          failedAt:
            challenge.failedAt instanceof Date
              ? challenge.failedAt
              : challenge.failedAt
                ? new Date(challenge.failedAt as any)
                : undefined,
          totalPenaltyPaid: challenge.totalPenaltyPaid,
          createdAt:
            challenge.createdAt instanceof Date
              ? challenge.createdAt
              : new Date(challenge.createdAt as any),
          updatedAt:
            challenge.updatedAt instanceof Date
              ? challenge.updatedAt
              : new Date(challenge.updatedAt as any),
        }));
        setChallenges(challengesData);

        // 支払い履歴を取得（ベストエフォート）
        try {
          const list = await PaymentFirestoreService.getUserPayments(user.uid);
          const mapped: Payment[] = list.map((p) => ({
            id: p.id,
            userId: p.userId,
            amount: p.amount,
            type: p.type as Payment["type"],
            status: p.status as Payment["status"],
            transactionId: p.transactionId ?? undefined,
            createdAt: p.createdAt instanceof Date ? p.createdAt : new Date(p.createdAt as any),
            updatedAt: p.updatedAt instanceof Date ? p.updatedAt : new Date(p.updatedAt as any),
          }));
          setPayments(mapped);
        } catch {
          setPayments([]);
        }
      } catch (error) {
        console.error("データの取得に失敗しました:", error);
      }
    };

    void fetchData();
  }, [user]);

  const handleRefresh = async () => {
    setRefreshing(true);
    if (!user?.uid) {
      setRefreshing(false);
      return;
    }

    try {
      // チャレンジ履歴を再取得
      const firestoreChallenges = await ChallengeService.getUserChallenges(
        user.uid,
      );
      const challengesData = firestoreChallenges.map((challenge) => ({
        id: challenge.id,
        userId: challenge.userId,
        goalDays: challenge.goalDays,
        penaltyAmount: challenge.penaltyAmount,
        status: challenge.status,
        startedAt:
          challenge.startedAt instanceof Date
            ? challenge.startedAt
            : new Date(challenge.startedAt as any),
        completedAt:
          challenge.completedAt instanceof Date
            ? challenge.completedAt
            : challenge.completedAt
              ? new Date(challenge.completedAt as any)
              : undefined,
        failedAt:
          challenge.failedAt instanceof Date
            ? challenge.failedAt
            : challenge.failedAt
              ? new Date(challenge.failedAt as any)
              : undefined,
        totalPenaltyPaid: challenge.totalPenaltyPaid,
        createdAt:
          challenge.createdAt instanceof Date
            ? challenge.createdAt
            : new Date(challenge.createdAt as any),
        updatedAt:
          challenge.updatedAt instanceof Date
            ? challenge.updatedAt
            : new Date(challenge.updatedAt as any),
      }));
      setChallenges(challengesData);

      // 支払い履歴を再取得
      try {
        const list = await PaymentFirestoreService.getUserPayments(user.uid);
        const mapped: Payment[] = list.map((p) => ({
          id: p.id,
          userId: p.userId,
          amount: p.amount,
          type: p.type as Payment["type"],
          status: p.status as Payment["status"],
          transactionId: p.transactionId ?? undefined,
          createdAt: p.createdAt instanceof Date ? p.createdAt : new Date(p.createdAt as any),
          updatedAt: p.updatedAt instanceof Date ? p.updatedAt : new Date(p.updatedAt as any),
        }));
        setPayments(mapped);
      } catch {
        setPayments([]);
      }
    } catch (error) {
      console.error("データの再取得に失敗しました:", error);
    } finally {
      setRefreshing(false);
    }
  };

  const challengeStats = StatsService.calculateStats(challenges);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={colors.textPrimary} />
        </TouchableOpacity>
        <Text style={styles.title}>履歴</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.content}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={() => {
              void handleRefresh();
            }}
            colors={[colors.primary]}
            tintColor={colors.primary}
          />
        }
      >
        {/* あなたの記録カード */}
        <View style={styles.recordCard}>
          <View style={styles.recordHeader}>
            <View style={styles.waveIcon}>
              <Ionicons name="pulse" size={24} color={colors.white} />
            </View>
            <Text style={styles.recordTitle}>あなたの記録</Text>
          </View>

          <View style={styles.recordStats}>
            <View style={styles.statBox}>
              <View style={styles.statIcon}>
                <Ionicons name="time" size={20} color={colors.white} />
              </View>
              <Text style={styles.statLabel}>平均時間</Text>
              {(() => {
                const formatted = StatsService.formatDuration(
                  challengeStats.averageTime,
                );
                const { days, time } =
                  StatsService.splitFormattedDuration(formatted);
                return (
                  <>
                    <Text style={styles.statValue}>
                      {challengeStats.averageTime > 0 ? days : "0日"}
                    </Text>
                    <Text style={styles.statSubValue}>
                      {challengeStats.averageTime > 0 ? time : "00:00:00"}
                    </Text>
                  </>
                );
              })()}
            </View>

            <View style={styles.statBox}>
              <View style={styles.statIcon}>
                <Ionicons name="trophy" size={20} color={colors.white} />
              </View>
              <Text style={styles.statLabel}>最長記録</Text>
              {(() => {
                const formatted = StatsService.formatDuration(
                  challengeStats.longestTime,
                );
                const { days, time } =
                  StatsService.splitFormattedDuration(formatted);
                return (
                  <>
                    <Text style={styles.statValue}>
                      {challengeStats.longestTime > 0 ? days : "0日"}
                    </Text>
                    <Text style={styles.statSubValue}>
                      {challengeStats.longestTime > 0 ? time : "00:00:00"}
                    </Text>
                  </>
                );
              })()}
            </View>
          </View>

          <View style={styles.challengeCountBox}>
            <View style={styles.challengeIcon}>
              <Ionicons name="flag" size={20} color={colors.white} />
            </View>
            <Text style={styles.challengeLabel}>チャレンジ回数</Text>
            <Text style={styles.challengeValue}>
              {challengeStats.totalChallenges}回
            </Text>
          </View>
        </View>

        {/* 過去の記録セクション */}
        <View style={styles.pastRecordsSection}>
          <View style={styles.pastRecordsHeader}>
            <Ionicons name="trophy" size={20} color={colors.textSecondary} />
            <Text style={styles.pastRecordsTitle}>過去の記録</Text>
          </View>

          {challenges.length > 0 ? (
            <FlatList
              data={challenges}
              renderItem={({ item }) => (
                <HistoryCard
                  item={item}
                  type="challenge"
                  onPress={() => {
                    /* noop */
                  }}
                />
              )}
              keyExtractor={(item) => item.id}
              scrollEnabled={false}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <View style={styles.emptyContainer}>
              <View style={styles.leafIcon}>
                <Ionicons name="leaf" size={32} color={colors.gray300} />
              </View>
              <Text style={styles.emptyTitle}>まだ記録がありません</Text>
              <Text style={styles.emptyText}>
                最初のチャレンジを始めましょう！
              </Text>
            </View>
          )}
        </View>

        {/* 支払い履歴セクション */}
        <View style={styles.pastRecordsSection}>
          <View style={styles.pastRecordsHeader}>
            <Ionicons name="card" size={20} color={colors.textSecondary} />
            <Text style={styles.pastRecordsTitle}>支払い履歴</Text>
          </View>

          {payments.length > 0 ? (
            <FlatList
              data={payments}
              renderItem={({ item }) => (
                <HistoryCard
                  item={item}
                  type="payment"
                  onPress={() => {
                    /* noop */
                  }}
                />
              )}
              keyExtractor={(item) => item.id}
              scrollEnabled={false}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <View style={styles.emptyContainer}>
              <View style={styles.leafIcon}>
                <Ionicons name="cash" size={32} color={colors.gray300} />
              </View>
              <Text style={styles.emptyTitle}>支払い履歴はありません</Text>
              <Text style={styles.emptyText}>ペナルティ支払いがここに表示されます</Text>
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: {
    padding: spacing.sm,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: "bold",
    color: colors.textPrimary,
    textAlign: "center",
    flex: 1,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  recordCard: {
    backgroundColor: screenThemes.history.cardBg,
    margin: spacing.xl,
    borderRadius: 20,
    padding: spacing.xl,
  },
  recordHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.xl,
  },
  waveIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginRight: spacing.md,
  },
  recordTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
  },
  recordStats: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: spacing.xl,
  },
  statBox: {
    flex: 1,
    alignItems: "center",
    marginHorizontal: spacing.sm,
    backgroundColor: screenThemes.history.tintSoft,
    borderRadius: 16,
    padding: spacing.lg,
  },
  statIcon: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: screenThemes.history.badgeBg || "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  statLabel: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    marginBottom: spacing.xs,
    textAlign: "center",
  },
  statValue: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
    marginBottom: spacing.xs,
  },
  statSubValue: {
    fontSize: typography.fontSize.sm,
    color: "rgba(255, 255, 255, 0.8)",
  },
  challengeCountBox: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: screenThemes.history.tintSoft,
    borderRadius: 16,
    padding: spacing.lg,
  },
  challengeIcon: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: screenThemes.history.badgeBg || "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginRight: spacing.md,
  },
  challengeLabel: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    marginRight: spacing.sm,
  },
  challengeValue: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
  },
  pastRecordsSection: {
    padding: spacing.xl,
  },
  pastRecordsHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.xl,
  },
  pastRecordsTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textPrimary,
    marginLeft: spacing.sm,
  },
  emptyContainer: {
    alignItems: "center",
    paddingVertical: spacing["4xl"],
  },
  leafIcon: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: colors.gray100,
    justifyContent: "center",
    alignItems: "center",
    marginBottom: spacing.lg,
  },
  emptyTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textSecondary,
    marginBottom: spacing.sm,
  },
  emptyText: {
    fontSize: typography.fontSize.sm,
    color: colors.textTertiary,
    textAlign: "center",
  },
});

export default HistoryScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation, useFocusEffect } from "@react-navigation/native";
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  ScrollView,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { ChallengeService, PaymentFirestoreService } from "@core/services/firestore";
import { StatsService } from "@core/services/statsService";
import HistoryCard from "@features/history/components/HistoryCard";
import type { Challenge, Payment } from "@project-types";
import { colors, spacing, typography } from "@shared/theme";
import { screenThemes } from "@shared/theme/screenThemes";

const HistoryScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [challenges, setChallenges] = useState<Challenge[]>([]);
  const [payments, setPayments] = useState<Payment[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  // 進行中の時間表示は各カード側で処理するため、画面全体の毎秒再レンダは不要

  // Firestoreからデータを取得
  useEffect(() => {
    const fetchData = async () => {
      if (!user?.uid) {
        return;
      }

      try {
        // チャレンジ履歴を取得
        const firestoreChallenges = await ChallengeService.getUserChallenges(
          user.uid,
        );
        const challengesData = firestoreChallenges.map((challenge) => ({
          id: challenge.id,
          userId: challenge.userId,
          goalDays: challenge.goalDays,
          penaltyAmount: challenge.penaltyAmount,
          status: challenge.status,
          startedAt:
            challenge.startedAt instanceof Date
              ? challenge.startedAt
              : new Date(challenge.startedAt as any),
          completedAt:
            challenge.completedAt instanceof Date
              ? challenge.completedAt
              : challenge.completedAt
                ? new Date(challenge.completedAt as any)
                : undefined,
          failedAt:
            challenge.failedAt instanceof Date
              ? challenge.failedAt
              : challenge.failedAt
                ? new Date(challenge.failedAt as any)
                : undefined,
          totalPenaltyPaid: challenge.totalPenaltyPaid,
          createdAt:
            challenge.createdAt instanceof Date
              ? challenge.createdAt
              : new Date(challenge.createdAt as any),
          updatedAt:
            challenge.updatedAt instanceof Date
              ? challenge.updatedAt
              : new Date(challenge.updatedAt as any),
        }));
        setChallenges(challengesData);

        // 支払い履歴を取得（ベストエフォート）
        try {
          const list = await PaymentFirestoreService.getUserPayments(user.uid);
          const mapped: Payment[] = list.map((p) => ({
            id: p.id,
            userId: p.userId,
            amount: p.amount,
            type: p.type as Payment["type"],
            status: p.status as Payment["status"],
            transactionId: p.transactionId ?? undefined,
            createdAt: p.createdAt instanceof Date ? p.createdAt : new Date(p.createdAt as any),
            updatedAt: p.updatedAt instanceof Date ? p.updatedAt : new Date(p.updatedAt as any),
          }));
          setPayments(mapped);
        } catch {
          setPayments([]);
        }
      } catch (error) {
        console.error("データの取得に失敗しました:", error);
      }
    };

    void fetchData();
  }, [user]);

  const handleRefresh = async () => {
    setRefreshing(true);
    if (!user?.uid) {
      setRefreshing(false);
      return;
    }

    try {
      // チャレンジ履歴を再取得
      const firestoreChallenges = await ChallengeService.getUserChallenges(
        user.uid,
      );
      const challengesData = firestoreChallenges.map((challenge) => ({
        id: challenge.id,
        userId: challenge.userId,
        goalDays: challenge.goalDays,
        penaltyAmount: challenge.penaltyAmount,
        status: challenge.status,
        startedAt:
          challenge.startedAt instanceof Date
            ? challenge.startedAt
            : new Date(challenge.startedAt as any),
        completedAt:
          challenge.completedAt instanceof Date
            ? challenge.completedAt
            : challenge.completedAt
              ? new Date(challenge.completedAt as any)
              : undefined,
        failedAt:
          challenge.failedAt instanceof Date
            ? challenge.failedAt
            : challenge.failedAt
              ? new Date(challenge.failedAt as any)
              : undefined,
        totalPenaltyPaid: challenge.totalPenaltyPaid,
        createdAt:
          challenge.createdAt instanceof Date
            ? challenge.createdAt
            : new Date(challenge.createdAt as any),
        updatedAt:
          challenge.updatedAt instanceof Date
            ? challenge.updatedAt
            : new Date(challenge.updatedAt as any),
      }));
      setChallenges(challengesData);

      // 支払い履歴を再取得
      try {
        const list = await PaymentFirestoreService.getUserPayments(user.uid);
        const mapped: Payment[] = list.map((p) => ({
          id: p.id,
          userId: p.userId,
          amount: p.amount,
          type: p.type as Payment["type"],
          status: p.status as Payment["status"],
          transactionId: p.transactionId ?? undefined,
          createdAt: p.createdAt instanceof Date ? p.createdAt : new Date(p.createdAt as any),
          updatedAt: p.updatedAt instanceof Date ? p.updatedAt : new Date(p.updatedAt as any),
        }));
        setPayments(mapped);
      } catch {
        setPayments([]);
      }
    } catch (error) {
      console.error("データの再取得に失敗しました:", error);
    } finally {
      setRefreshing(false);
    }
  };

  const challengeStats = StatsService.calculateStats(challenges);

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={colors.textPrimary} />
        </TouchableOpacity>
        <Text style={styles.title}>履歴</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.content}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={() => {
              void handleRefresh();
            }}
            colors={[colors.primary]}
            tintColor={colors.primary}
          />
        }
      >
        {/* あなたの記録カード */}
        <View style={styles.recordCard}>
          <View style={styles.recordHeader}>
            <View style={styles.waveIcon}>
              <Ionicons name="pulse" size={24} color={colors.white} />
            </View>
            <Text style={styles.recordTitle}>あなたの記録</Text>
          </View>

          <View style={styles.recordStats}>
            <View style={styles.statBox}>
              <View style={styles.statIcon}>
                <Ionicons name="time" size={20} color={colors.white} />
              </View>
              <Text style={styles.statLabel}>平均時間</Text>
              {(() => {
                const formatted = StatsService.formatDuration(
                  challengeStats.averageTime,
                );
                const { days, time } =
                  StatsService.splitFormattedDuration(formatted);
                return (
                  <>
                    <Text style={styles.statValue}>
                      {challengeStats.averageTime > 0 ? days : "0日"}
                    </Text>
                    <Text style={styles.statSubValue}>
                      {challengeStats.averageTime > 0 ? time : "00:00:00"}
                    </Text>
                  </>
                );
              })()}
            </View>

            <View style={styles.statBox}>
              <View style={styles.statIcon}>
                <Ionicons name="trophy" size={20} color={colors.white} />
              </View>
              <Text style={styles.statLabel}>最長記録</Text>
              {(() => {
                const formatted = StatsService.formatDuration(
                  challengeStats.longestTime,
                );
                const { days, time } =
                  StatsService.splitFormattedDuration(formatted);
                return (
                  <>
                    <Text style={styles.statValue}>
                      {challengeStats.longestTime > 0 ? days : "0日"}
                    </Text>
                    <Text style={styles.statSubValue}>
                      {challengeStats.longestTime > 0 ? time : "00:00:00"}
                    </Text>
                  </>
                );
              })()}
            </View>
          </View>

          <View style={styles.challengeCountBox}>
            <View style={styles.challengeIcon}>
              <Ionicons name="flag" size={20} color={colors.white} />
            </View>
            <Text style={styles.challengeLabel}>チャレンジ回数</Text>
            <Text style={styles.challengeValue}>
              {challengeStats.totalChallenges}回
            </Text>
          </View>
        </View>

        {/* 過去の記録セクション */}
        <View style={styles.pastRecordsSection}>
          <View style={styles.pastRecordsHeader}>
            <Ionicons name="trophy" size={20} color={colors.textSecondary} />
            <Text style={styles.pastRecordsTitle}>過去の記録</Text>
          </View>

          {challenges.length > 0 ? (
            <FlatList
              data={challenges}
              renderItem={({ item }) => (
                <HistoryCard
                  item={item}
                  type="challenge"
                  onPress={() => {
                    /* noop */
                  }}
                />
              )}
              keyExtractor={(item) => item.id}
              scrollEnabled={false}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <View style={styles.emptyContainer}>
              <View style={styles.leafIcon}>
                <Ionicons name="leaf" size={32} color={colors.gray300} />
              </View>
              <Text style={styles.emptyTitle}>まだ記録がありません</Text>
              <Text style={styles.emptyText}>
                最初のチャレンジを始めましょう！
              </Text>
            </View>
          )}
        </View>

        {/* 支払い履歴セクション */}
        <View style={styles.pastRecordsSection}>
          <View style={styles.pastRecordsHeader}>
            <Ionicons name="card" size={20} color={colors.textSecondary} />
            <Text style={styles.pastRecordsTitle}>支払い履歴</Text>
          </View>

          {payments.length > 0 ? (
            <FlatList
              data={payments}
              renderItem={({ item }) => (
                <HistoryCard
                  item={item}
                  type="payment"
                  onPress={() => {
                    /* noop */
                  }}
                />
              )}
              keyExtractor={(item) => item.id}
              scrollEnabled={false}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <View style={styles.emptyContainer}>
              <View style={styles.leafIcon}>
                <Ionicons name="cash" size={32} color={colors.gray300} />
              </View>
              <Text style={styles.emptyTitle}>支払い履歴はありません</Text>
              <Text style={styles.emptyText}>ペナルティ支払いがここに表示されます</Text>
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: {
    padding: spacing.sm,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: "bold",
    color: colors.textPrimary,
    textAlign: "center",
    flex: 1,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  recordCard: {
    backgroundColor: screenThemes.history.cardBg,
    margin: spacing.xl,
    borderRadius: 20,
    padding: spacing.xl,
  },
  recordHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.xl,
  },
  waveIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginRight: spacing.md,
  },
  recordTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
  },
  recordStats: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: spacing.xl,
  },
  statBox: {
    flex: 1,
    alignItems: "center",
    marginHorizontal: spacing.sm,
    backgroundColor: screenThemes.history.tintSoft,
    borderRadius: 16,
    padding: spacing.lg,
  },
  statIcon: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: screenThemes.history.badgeBg || "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  statLabel: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    marginBottom: spacing.xs,
    textAlign: "center",
  },
  statValue: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
    marginBottom: spacing.xs,
  },
  statSubValue: {
    fontSize: typography.fontSize.sm,
    color: "rgba(255, 255, 255, 0.8)",
  },
  challengeCountBox: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: screenThemes.history.tintSoft,
    borderRadius: 16,
    padding: spacing.lg,
  },
  challengeIcon: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: screenThemes.history.badgeBg || "rgba(255, 255, 255, 0.2)",
    justifyContent: "center",
    alignItems: "center",
    marginRight: spacing.md,
  },
  challengeLabel: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    marginRight: spacing.sm,
  },
  challengeValue: {
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.white,
  },
  pastRecordsSection: {
    padding: spacing.xl,
  },
  pastRecordsHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.xl,
  },
  pastRecordsTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textPrimary,
    marginLeft: spacing.sm,
  },
  emptyContainer: {
    alignItems: "center",
    paddingVertical: spacing["4xl"],
  },
  leafIcon: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: colors.gray100,
    justifyContent: "center",
    alignItems: "center",
    marginBottom: spacing.lg,
  },
  emptyTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textSecondary,
    marginBottom: spacing.sm,
  },
  emptyText: {
    fontSize: typography.fontSize.sm,
    color: colors.textTertiary,
    textAlign: "center",
  },
});

export default HistoryScreen;

*** Update File: src/features/community/screens/CommunityScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import CreatePostModal from "@features/community/components/CreatePostModal";
import PostList from "@features/community/components/PostList";
import useCommunity from "@features/community/hooks/useCommunity";
import type { CommunityPost } from "@project-types";
import Button from "@shared/components/Button";
import KeyboardAwareScrollView from "@shared/components/KeyboardAwareScrollView";
import ReplyInputBar from "@shared/components/ReplyInputBar";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";

type Nav = StackNavigationProp<TournamentStackParamList>;

const CommunityScreen: React.FC = () => {
  const navigation = useNavigation<Nav>();
  const [state, actions] = useCommunity();
  const { requireAuth } = useAuthPrompt();
  const {
    posts,
    likedPosts,
    activeTab,
    replyingTo,
    replyText,
    showReplyButtons,
    replyCounts,
    userAverageDays,
    refreshing,
    showCreateModal,
    loadingMore,
    hasMore,
  } = state;
  const {
    setShowCreateModal,
    handleRefresh,
    handleCreatePost,
    handleLike,
    handleComment,
    handleReply,
    handleReplySubmit,
    handleReplyCancel,
    handleTabPress,
    setReplyText,
    loadMore,
  } = actions;
  // 相対時間は各セル内の RelativeTime コンポーネントで個別に更新する

  const handlePostPress = useCallback(
    (post: CommunityPost) => {
      navigateToUserDetail(
        navigation,
        post.authorId,
        post.authorName,
        post.authorAvatar,
      );
    },
    [navigation],
  );

  // PostList が各種描画を担当

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "all" && uiStyles.tabActive]}
          onPress={() => handleTabPress("all")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "all" && uiStyles.tabTextActive,
            ]}
          >
            すべて
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "my" && uiStyles.tabActive]}
          onPress={() => handleTabPress("my")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "my" && uiStyles.tabTextActive,
            ]}
          >
            My投稿
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            uiStyles.tab,
            activeTab === "following" && uiStyles.tabActive,
          ]}
          onPress={() => handleTabPress("following")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "following" && uiStyles.tabTextActive,
            ]}
          >
            フォロー
          </Text>
        </TouchableOpacity>
      </View>

      <KeyboardAwareScrollView>
        <PostList
          key={`postlist-${activeTab}`}
          posts={posts}
          likedPosts={likedPosts}
          showReplyButtons={showReplyButtons}
          replyCounts={replyCounts}
          authorAverageDays={userAverageDays}
          hasMore={activeTab === "all" ? hasMore : false}
          onLike={(id) => {
            void handleLike(id);
          }}
          onComment={handleComment}
          onReply={handleReply}
          onUserPress={(uid, uname) =>
            handlePostPress({
              authorId: uid,
              authorName: uname,
            } as CommunityPost)
          }
          contentContainerStyle={uiStyles.listContainer}
          onEndReached={() => {
            if (!hasMore || loadingMore || posts.length === 0) return;
            void loadMore();
          }}
          onEndReachedThreshold={0.4}
          loadingMore={loadingMore}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
          }
          ListEmptyComponent={
            posts.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Ionicons
                  name="chatbubble-outline"
                  size={64}
                  color={colors.gray300}
                />
                <Text style={styles.emptyTitle}>
                  {activeTab === "all" && "投稿がありません"}
                  {activeTab === "my" && "自分の投稿がありません"}
                  {activeTab === "following" && "フォロー中の投稿がありません"}
                </Text>
                <Text style={styles.emptyText}>
                  {activeTab === "all" && "最初の投稿を作成してみましょう"}
                  {activeTab === "my" && "まだ投稿していません"}
                  {activeTab === "following" &&
                    "フォローしているユーザーがいません"}
                </Text>
                {activeTab === "all" && (
                  <Button
                    title="投稿を作成"
                    onPress={() => setShowCreateModal(true)}
                    style={styles.emptyButton}
                  />
                )}
                {activeTab === "following" && (
                  <Button
                    title="投稿者をフォロー"
                    onPress={() => {
                      /* noop */
                    }}
                    style={styles.emptyButton}
                  />
                )}
              </View>
            ) : null
          }
        />
      </KeyboardAwareScrollView>

      {replyingTo && (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "padding"}
          keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 16}
        >
          <ReplyInputBar
            value={replyText}
            onChangeText={setReplyText}
            onCancel={handleReplyCancel}
            onSubmit={() => {
              void handleReplySubmit();
            }}
            autoFocus
          />
        </KeyboardAvoidingView>
      )}

      <TouchableOpacity
        style={styles.fab}
        onPress={async () => {
          const ok = await requireAuth();
          if (ok) setShowCreateModal(true);
        }}
      >
        <Ionicons name="add" size={24} color={colors.white} />
      </TouchableOpacity>

      <CreatePostModal
        visible={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onSubmit={(data) => {
          void handleCreatePost(data);
        }}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: "700",
    color: colors.textPrimary,
    textAlign: "center",
  },
  tabContainer: {
    flexDirection: "row",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  tab: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    marginRight: spacing["3xl"],
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
  },
  tabText: {
    fontSize: typography.fontSize.base,
    fontWeight: "500",
    color: colors.textSecondary,
  },
  activeTabText: {
    color: colors.info,
  },
  listContainer: {
    padding: spacing.xl,
    backgroundColor: colors.backgroundSecondary,
  },
  fab: {
    position: "absolute",
    bottom: spacing.xl,
    right: spacing.xl,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
    ...shadows.lg,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: spacing["5xl"],
  },
  emptyTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: "600",
    color: colors.textSecondary,
    marginTop: spacing.lg,
    marginBottom: spacing.sm,
  },
  emptyText: {
    fontSize: typography.fontSize.sm,
    color: colors.textTertiary,
    textAlign: "center",
    marginBottom: spacing["2xl"],
  },
  emptyButton: {
    paddingHorizontal: spacing["3xl"],
  },
  replyInputContainer: {
    backgroundColor: colors.gray50,
    padding: spacing.lg,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  replyInput: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.md,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    minHeight: 80,
    textAlignVertical: "top",
    marginBottom: spacing.md,
  },
  replyInputActions: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    gap: spacing.md,
  },
  replyCancelButton: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
  },
  replyCancelText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium,
  },
  replySubmitButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
    minWidth: 60,
    alignItems: "center",
  },
  replySubmitButtonDisabled: {
    backgroundColor: colors.gray300,
  },
  replySubmitText: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    fontWeight: typography.fontWeight.semibold,
  },
  replySubmitTextDisabled: {
    color: colors.gray500,
  },
});

export default CommunityScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import CreatePostModal from "@features/community/components/CreatePostModal";
import PostList from "@features/community/components/PostList";
import useCommunity from "@features/community/hooks/useCommunity";
import type { CommunityPost } from "@project-types";
import Button from "@shared/components/Button";
import KeyboardAwareScrollView from "@shared/components/KeyboardAwareScrollView";
import ReplyInputBar from "@shared/components/ReplyInputBar";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";

type Nav = StackNavigationProp<TournamentStackParamList>;

const CommunityScreen: React.FC = () => {
  const navigation = useNavigation<Nav>();
  const [state, actions] = useCommunity();
  const { requireAuth } = useAuthPrompt();
  const {
    posts,
    likedPosts,
    activeTab,
    replyingTo,
    replyText,
    showReplyButtons,
    replyCounts,
    userAverageDays,
    refreshing,
    showCreateModal,
    loadingMore,
    hasMore,
  } = state;
  const {
    setShowCreateModal,
    handleRefresh,
    handleCreatePost,
    handleLike,
    handleComment,
    handleReply,
    handleReplySubmit,
    handleReplyCancel,
    handleTabPress,
    setReplyText,
    loadMore,
  } = actions;
  // 相対時間は各セル内の RelativeTime コンポーネントで個別に更新する

  const handlePostPress = useCallback(
    (post: CommunityPost) => {
      navigateToUserDetail(
        navigation,
        post.authorId,
        post.authorName,
        post.authorAvatar,
      );
    },
    [navigation],
  );

  // PostList が各種描画を担当

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "all" && uiStyles.tabActive]}
          onPress={() => handleTabPress("all")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "all" && uiStyles.tabTextActive,
            ]}
          >
            すべて
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "my" && uiStyles.tabActive]}
          onPress={() => handleTabPress("my")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "my" && uiStyles.tabTextActive,
            ]}
          >
            My投稿
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            uiStyles.tab,
            activeTab === "following" && uiStyles.tabActive,
          ]}
          onPress={() => handleTabPress("following")}
        >
          <Text
            style={[
              uiStyles.tabText,
              activeTab === "following" && uiStyles.tabTextActive,
            ]}
          >
            フォロー
          </Text>
        </TouchableOpacity>
      </View>

      <KeyboardAwareScrollView>
        <PostList
          key={`postlist-${activeTab}`}
          posts={posts}
          likedPosts={likedPosts}
          showReplyButtons={showReplyButtons}
          replyCounts={replyCounts}
          authorAverageDays={userAverageDays}
          hasMore={activeTab === "all" ? hasMore : false}
          onLike={(id) => {
            void handleLike(id);
          }}
          onComment={handleComment}
          onReply={handleReply}
          onUserPress={(uid, uname) =>
            handlePostPress({
              authorId: uid,
              authorName: uname,
            } as CommunityPost)
          }
          contentContainerStyle={uiStyles.listContainer}
          onEndReached={() => {
            if (!hasMore || loadingMore || posts.length === 0) return;
            void loadMore();
          }}
          onEndReachedThreshold={0.4}
          loadingMore={loadingMore}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
          }
          ListEmptyComponent={
            posts.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Ionicons
                  name="chatbubble-outline"
                  size={64}
                  color={colors.gray300}
                />
                <Text style={styles.emptyTitle}>
                  {activeTab === "all" && "投稿がありません"}
                  {activeTab === "my" && "自分の投稿がありません"}
                  {activeTab === "following" && "フォロー中の投稿がありません"}
                </Text>
                <Text style={styles.emptyText}>
                  {activeTab === "all" && "最初の投稿を作成してみましょう"}
                  {activeTab === "my" && "まだ投稿していません"}
                  {activeTab === "following" &&
                    "フォローしているユーザーがいません"}
                </Text>
                {activeTab === "all" && (
                  <Button
                    title="投稿を作成"
                    onPress={() => setShowCreateModal(true)}
                    style={styles.emptyButton}
                  />
                )}
                {activeTab === "following" && (
                  <Button
                    title="投稿者をフォロー"
                    onPress={() => {
                      /* noop */
                    }}
                    style={styles.emptyButton}
                  />
                )}
              </View>
            ) : null
          }
        />
      </KeyboardAwareScrollView>

      {replyingTo && (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "padding"}
          keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 16}
        >
          <ReplyInputBar
            value={replyText}
            onChangeText={setReplyText}
            onCancel={handleReplyCancel}
            onSubmit={() => {
              void handleReplySubmit();
            }}
            autoFocus
          />
        </KeyboardAvoidingView>
      )}

      <TouchableOpacity
        style={styles.fab}
        onPress={async () => {
          const ok = await requireAuth();
          if (ok) setShowCreateModal(true);
        }}
      >
        <Ionicons name="add" size={24} color={colors.white} />
      </TouchableOpacity>

      <CreatePostModal
        visible={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onSubmit={(data) => {
          void handleCreatePost(data);
        }}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: "700",
    color: colors.textPrimary,
    textAlign: "center",
  },
  tabContainer: {
    flexDirection: "row",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  tab: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    marginRight: spacing["3xl"],
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
  },
  tabText: {
    fontSize: typography.fontSize.base,
    fontWeight: "500",
    color: colors.textSecondary,
  },
  activeTabText: {
    color: colors.info,
  },
  listContainer: {
    padding: spacing.xl,
    backgroundColor: colors.backgroundSecondary,
  },
  fab: {
    position: "absolute",
    bottom: spacing.xl,
    right: spacing.xl,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
    ...shadows.lg,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: spacing["5xl"],
  },
  emptyTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: "600",
    color: colors.textSecondary,
    marginTop: spacing.lg,
    marginBottom: spacing.sm,
  },
  emptyText: {
    fontSize: typography.fontSize.sm,
    color: colors.textTertiary,
    textAlign: "center",
    marginBottom: spacing["2xl"],
  },
  emptyButton: {
    paddingHorizontal: spacing["3xl"],
  },
  replyInputContainer: {
    backgroundColor: colors.gray50,
    padding: spacing.lg,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  replyInput: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.md,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    minHeight: 80,
    textAlignVertical: "top",
    marginBottom: spacing.md,
  },
  replyInputActions: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    gap: spacing.md,
  },
  replyCancelButton: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
  },
  replyCancelText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium,
  },
  replySubmitButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
    minWidth: 60,
    alignItems: "center",
  },
  replySubmitButtonDisabled: {
    backgroundColor: colors.gray300,
  },
  replySubmitText: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    fontWeight: typography.fontWeight.semibold,
  },
  replySubmitTextDisabled: {
    color: colors.gray500,
  },
});

export default CommunityScreen;

*** Update File: src/features/ranking/screens/RankingScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  ScrollView,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import { RankingService } from "@core/services/rankingService";
import type { UserRanking } from "@core/services/rankingService";
import { UserStatsService } from "@core/services/userStatsService";
import RankingListItem from "@features/ranking/components/RankingListItem";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useFollowingIds } from "@shared/state/followStore";
import { uiStyles } from "@shared/ui/styles";

const RankingScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation =
    useNavigation<StackNavigationProp<TournamentStackParamList>>();
  const [rankings, setRankings] = useState<UserRanking[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [cursor, setCursor] = useState<{ startedAt: string; userId: string } | undefined>(undefined);
  const [hasMore, setHasMore] = useState(true);
  const [avgDaysMap, setAvgDaysMap] = useState<Map<string, number>>(new Map());
  const [activeTab, setActiveTab] = useState<"all" | "following">("all");
  const [showTiers, setShowTiers] = useState(false);
  const followingIds = useFollowingIds();

  useEffect(() => {
    void refreshRankings();
  }, [activeTab]);
  useEffect(() => {
    if (activeTab === "following") {
      void refreshRankings();
    }
  }, [followingIds, user?.uid, activeTab]);

  const PAGE_SIZE = 50;

  const refreshRankings = async () => {
    try {
      if (activeTab === "all") {
        const { items, nextCursor } = await RankingService.getUserRankingsPage(PAGE_SIZE);
        items.forEach((r, i) => (r.rank = i + 1));
        setRankings(items);
        setCursor(nextCursor);
        setHasMore(Boolean(nextCursor));
        const next = new Map<string, number>();
        items.forEach((r) => {
          const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
          next.set(r.id, Math.max(0, days));
        });
        setAvgDaysMap(next);
      } else {
        const idsSet = new Set<string>(Array.from(followingIds));
        if (user?.uid) idsSet.add(user.uid);
        const ids = Array.from(idsSet);
        if (ids.length === 0) {
          setRankings([]);
          setCursor(undefined);
          setHasMore(false);
          setAvgDaysMap(new Map());
        } else {
          const list = await RankingService.getUserRankingsForUserIds(ids);
          list.forEach((r, i) => (r.rank = i + 1));
          setRankings(list);
          setCursor(undefined);
          setHasMore(false);
          const next = new Map<string, number>();
          list.forEach((r) => {
            const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
            next.set(r.id, Math.max(0, days));
          });
          setAvgDaysMap(next);
        }
      }
    } catch {
      setRankings([]);
      setCursor(undefined);
      setHasMore(false);
      setAvgDaysMap(new Map());
    }
  };

  const loadMore = async () => {
    if (loadingMore || !hasMore) return;
    if (activeTab !== "all") return;
    setLoadingMore(true);
    try {
      const { items, nextCursor } = await RankingService.getUserRankingsPage(PAGE_SIZE, cursor);
      const offset = rankings.length;
      items.forEach((r, i) => (r.rank = offset + i + 1));
      const mergedIds = new Set(rankings.map((r) => r.id));
      const dedup = [...rankings];
      for (const r of items) {
        if (!mergedIds.has(r.id)) dedup.push(r);
      }
      setRankings(dedup);
      setCursor(nextCursor);
      setHasMore(Boolean(nextCursor));
      setAvgDaysMap((prev) => {
        const next = new Map(prev);
        items.forEach((r) => {
          const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
          next.set(r.id, Math.max(0, days));
        });
        return next;
      });
    } finally {
      setLoadingMore(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await refreshRankings();
    setRefreshing(false);
  };

  const getCurrentUserRank = () => {
    if (!user || rankings.length === 0) return null;
    const currentUserRanking = rankings.find(
      (ranking) => ranking.id === user.uid,
    );
    return currentUserRanking ? currentUserRanking.rank : null;
  };

  const getRankIcon = (rank: number) => {
    switch (rank) {
      case 1:
        return "trophy";
      case 2:
        return "medal";
      case 3:
        return "medal-outline";
      default:
        return "person";
    }
  };

  const getRankColor = (rank: number) => {
    switch (rank) {
      case 1:
        return "#F59E0B";
      case 2:
        return "#6B7280";
      case 3:
        return "#9CA3AF";
      default:
        return "#111827";
    }
  };

  const handleUserPress = (
    userId: string,
    userName: string,
    userAvatar?: string,
  ) => {
    navigateToUserDetail(navigation, userId, userName, userAvatar);
  };

  const onUserPress = useCallback(
    (userId: string, userName: string, userAvatar?: string) => {
      navigateToUserDetail(navigation, userId, userName, userAvatar);
    },
    [navigation],
  );

  const renderRankingItem = useCallback(
    ({ item }: { item: UserRanking }) => (
      <RankingListItem
        item={item}
        avgDays={avgDaysMap.get(item.id) ?? 0}
        currentUserId={user?.uid}
        onPress={onUserPress}
      />
    ),
    [avgDaysMap, user?.uid, onUserPress],
  );

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor={"#F5F5F7"} />

      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => {
            navigation.goBack();
          }}
        >
          <Ionicons name="arrow-back" size={24} color={"#111827"} />
        </TouchableOpacity>
        <Text style={styles.title}>ランキング</Text>
        <View style={styles.placeholder} />
      </View>

      {/* タブ切り替え */}
      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "all" && uiStyles.tabActive]}
          onPress={() => {
            if (activeTab !== "all") setActiveTab("all");
          }}
        >
          <Text style={[uiStyles.tabText, activeTab === "all" && uiStyles.tabTextActive]}>全体</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "following" && uiStyles.tabActive]}
          onPress={() => {
            if (activeTab !== "following") setActiveTab("following");
          }}
        >
          <Text style={[uiStyles.tabText, activeTab === "following" && uiStyles.tabTextActive]}>フォロー</Text>
        </TouchableOpacity>
      </View>

      <FlatList
        style={styles.content}
        data={rankings}
        renderItem={renderRankingItem}
        keyExtractor={(item) => item.id}
        onEndReachedThreshold={0.5}
        onEndReached={() => { void loadMore(); }}
        removeClippedSubviews
        windowSize={5}
        maxToRenderPerBatch={24}
        initialNumToRender={12}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={() => {
              void handleRefresh();
            }}
            colors={["#2563EB"]}
            tintColor={"#2563EB"}
          />
        }
        ListFooterComponent={
          loadingMore ? (
            <View style={{ padding: 16, alignItems: "center" }}>
              <Text style={{ color: "#6B7280" }}>読み込み中...</Text>
            </View>
          ) : null
        }
        ListHeaderComponent={
          <View style={styles.descriptionCard}>
            <View style={styles.descriptionHeader}>
              <Ionicons name="trophy" size={24} color={"#F59E0B"} />
              <Text style={styles.descriptionTitle}>ランキング</Text>
              <TouchableOpacity
                onPress={() => setShowTiers((v) => !v)}
                style={{ marginLeft: 'auto' }}
              >
                <Text style={{ color: '#2563EB', fontWeight: '600' }}>
                  {showTiers ? '説明を非表示' : '説明を表示'}
                </Text>
              </TouchableOpacity>
            </View>
            <Text style={styles.descriptionText}>
              現在の継続時間でランキングしています。
            </Text>
            {showTiers && (
            <View style={styles.tierCard}>
              <Text style={styles.tierTitle}>階級について</Text>
              <Text style={styles.tierText}>
                禁欲の現在の継続日数（挑戦中の記録）に応じて階級（称号）が上がります。目安は以下の通りです。
              </Text>
              <ScrollView
                style={styles.tierScrollView}
                showsVerticalScrollIndicator={false}
              >
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>訓練兵 🔰</Text>
                  <Text style={styles.tierRule}>
                    0日: 禁欲のスタート地点。まずは1日から始めましょう。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>二等兵 🔰⭐</Text>
                  <Text style={styles.tierRule}>
                    1日: 初回の達成。習慣化への第一歩です。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>一等兵 🔰⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    2日: 少しずつ習慣が身についてきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>上等兵 🔰⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    3〜6日: 1週間を目指す段階。体調の変化を感じ始めます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>兵長 🪙</Text>
                  <Text style={styles.tierRule}>
                    7〜13日: 1週間達成！安定期に入り、集中力が向上します。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>伍長 🛡️⭐</Text>
                  <Text style={styles.tierRule}>
                    14〜20日: 2週間を超えて、生活リズムが整ってきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>軍曹 🛡️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    21〜29日: 3週間達成。習慣が定着し、自信がついてきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>軍長 🛡️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    30〜39日: 1ヶ月達成！体調と集中力の変化を強く実感します。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>准尉 🎗️</Text>
                  <Text style={styles.tierRule}>
                    40〜49日: 長期継続の段階。周囲にも良い影響を与え始めます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>少尉 🎖️⭐</Text>
                  <Text style={styles.tierRule}>
                    50〜59日:
                    2ヶ月近く継続。意思決定がクリアになり、判断力が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中尉 🎖️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    60〜69日: 2ヶ月達成！反射的な衝動が弱まり、自制心が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大尉 🎖️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    70〜99日: 3ヶ月近く継続。生活が整い、目標達成能力が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>少佐 🏆⭐</Text>
                  <Text style={styles.tierRule}>
                    100〜149日:
                    100日達成！継続は最強の資産。ロールモデル的存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中佐 🏆⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    150〜199日: 5ヶ月継続。周囲の行動にも好影響を与える存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大佐 🏆⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    200〜299日:
                    半年以上継続。継続力が人生のあらゆる面で活かされます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>小将 🏵️⭐</Text>
                  <Text style={styles.tierRule}>
                    300〜399日: 10ヶ月継続。禁欲の達人として尊敬される存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中将 🏵️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    400〜499日: 1年以上継続。継続の真の価値を理解した存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大将 🏵️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    500〜999日: 1年半以上継続。継続の神として崇められる存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>ナポレオン 👑</Text>
                  <Text style={styles.tierRule}>
                    1000日以上:
                    3年近く継続。伝説的存在。継続の皇帝として永遠に語り継がれる。
                  </Text>
                </View>
              </ScrollView>
              <Text style={styles.tierNote}>
                階級は「現在の継続日数（挑戦中の記録）」から算出されます。停止・失敗で継続日数はリセットされますが、次の挑戦で少しずつ押し上げましょう。
              </Text>
            </View>
            )}
            {(() => {
              const currentUserRank = getCurrentUserRank();
              if (currentUserRank) {
                return (
                  <Text style={styles.currentUserRank}>
                    あなたの順位: {rankings.length}人中{currentUserRank}位
                  </Text>
                );
              } else {
                return (
                  <Text style={styles.participantCount}>
                    参加者: {rankings.length}人
                  </Text>
                );
              }
            })()}
          </View>
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons name="trophy-outline" size={64} color={"#9CA3AF"} />
            <Text style={styles.emptyTitle}>ランキングデータがありません</Text>
            <Text style={styles.emptyText}>
              {activeTab === 'following' ? 'フォローしているユーザーに対象者がいません' : 'チャレンジを完了したユーザーがいるとランキングが表示されます'}
            </Text>
          </View>
        }
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#F5F5F7",
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: "#FFFFFF",
    borderBottomWidth: 1,
    borderBottomColor: "#E5E7EB",
  },
  backButton: {
    padding: 8,
  },
  title: {
    fontSize: 20,
    fontWeight: "700",
    color: "#111827",
    textAlign: "center",
    flex: 1,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  descriptionCard: {
    backgroundColor: "#FEF3C7",
    margin: 16,
    borderRadius: 16,
    padding: 16,
  },
  descriptionHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  descriptionTitle: {
    fontSize: 18,
    fontWeight: "600",
    color: "#111827",
    marginLeft: 8,
  },
  descriptionText: {
    fontSize: 14,
    color: "#6B7280",
    lineHeight: 14 * 1.5,
  },
  tierCard: {
    backgroundColor: "#FFFFFF",
    borderRadius: 12,
    padding: 12,
    marginTop: 12,
    borderWidth: 1,
    borderColor: "#FDE68A",
    maxHeight: 400,
  },
  tierTitle: {
    fontSize: 16,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 8,
  },
  tierText: {
    fontSize: 13,
    color: "#6B7280",
    marginBottom: 8,
    lineHeight: 18,
  },
  tierScrollView: {
    maxHeight: 300,
  },
  tierItem: {
    marginBottom: 8,
  },
  tierBadge: {
    backgroundColor: "#E0F2FE",
    color: "#0369A1",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
    fontSize: 13,
    fontWeight: "700",
    marginBottom: 4,
    alignSelf: "flex-start",
  },
  tierRule: {
    fontSize: 13,
    color: "#374151",
    lineHeight: 18,
    marginLeft: 4,
  },
  tierNote: {
    marginTop: 8,
    fontSize: 12,
    color: "#6B7280",
  },
  participantCount: {
    fontSize: 14,
    color: "#6B7280",
    marginTop: 4,
    fontWeight: "500",
  },
  currentUserRank: {
    fontSize: 14,
    color: "#111827",
    marginTop: 4,
    fontWeight: "700",
  },
  rankingItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#FFFFFF",
    marginHorizontal: 16,
    marginVertical: 4,
    padding: 16,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOpacity: 0.05,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    position: "relative",
  },
  currentUserItem: {
    backgroundColor: "#FFFFFF",
    borderWidth: 2,
    borderColor: "#2563EB",
  },
  youBadgeContainer: {
    position: "absolute",
    top: -12,
    left: -6,
    backgroundColor: "#2563EB",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    zIndex: 2,
  },
  youBadgeText: {
    color: "#FFFFFF",
    fontSize: 12,
    fontWeight: "700",
  },
  rankContainer: {
    alignItems: "center",
    marginRight: 16,
    minWidth: 40,
  },
  userProfileContainer: {
    marginRight: 8,
  },
  rankNumber: {
    fontSize: 14,
    fontWeight: "700",
    marginTop: 4,
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 16,
    fontWeight: "600",
    color: "#111827",
    marginBottom: 4,
  },
  currentUserName: {
    color: "#111827",
    fontWeight: "700",
  },
  currentUserText: {
    color: "#111827",
  },
  averageTimeContainer: {
    marginBottom: 4,
  },
  averageTime: {
    fontSize: 14,
    color: "#6B7280",
    fontWeight: "500",
  },
  averageTimeSub: {
    fontSize: 14,
    color: "#9CA3AF",
    marginTop: 2,
    fontWeight: "500",
  },
  stats: {
    fontSize: 12,
    color: "#9CA3AF",
  },
  emptyContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 32,
    paddingHorizontal: 16,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: "600",
    color: "#6B7280",
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    color: "#9CA3AF",
    textAlign: "center",
    lineHeight: 14 * 1.5,
  },
});

export default RankingScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  SafeAreaView,
  StatusBar,
  ScrollView,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import { RankingService } from "@core/services/rankingService";
import type { UserRanking } from "@core/services/rankingService";
import { UserStatsService } from "@core/services/userStatsService";
import RankingListItem from "@features/ranking/components/RankingListItem";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useFollowingIds } from "@shared/state/followStore";
import { uiStyles } from "@shared/ui/styles";

const RankingScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation =
    useNavigation<StackNavigationProp<TournamentStackParamList>>();
  const [rankings, setRankings] = useState<UserRanking[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [cursor, setCursor] = useState<{ startedAt: string; userId: string } | undefined>(undefined);
  const [hasMore, setHasMore] = useState(true);
  const [avgDaysMap, setAvgDaysMap] = useState<Map<string, number>>(new Map());
  const [activeTab, setActiveTab] = useState<"all" | "following">("all");
  const [showTiers, setShowTiers] = useState(false);
  const followingIds = useFollowingIds();

  useEffect(() => {
    void refreshRankings();
  }, [activeTab]);
  useEffect(() => {
    if (activeTab === "following") {
      void refreshRankings();
    }
  }, [followingIds, user?.uid, activeTab]);

  const PAGE_SIZE = 50;

  const refreshRankings = async () => {
    try {
      if (activeTab === "all") {
        const { items, nextCursor } = await RankingService.getUserRankingsPage(PAGE_SIZE);
        items.forEach((r, i) => (r.rank = i + 1));
        setRankings(items);
        setCursor(nextCursor);
        setHasMore(Boolean(nextCursor));
        const next = new Map<string, number>();
        items.forEach((r) => {
          const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
          next.set(r.id, Math.max(0, days));
        });
        setAvgDaysMap(next);
      } else {
        const idsSet = new Set<string>(Array.from(followingIds));
        if (user?.uid) idsSet.add(user.uid);
        const ids = Array.from(idsSet);
        if (ids.length === 0) {
          setRankings([]);
          setCursor(undefined);
          setHasMore(false);
          setAvgDaysMap(new Map());
        } else {
          const list = await RankingService.getUserRankingsForUserIds(ids);
          list.forEach((r, i) => (r.rank = i + 1));
          setRankings(list);
          setCursor(undefined);
          setHasMore(false);
          const next = new Map<string, number>();
          list.forEach((r) => {
            const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
            next.set(r.id, Math.max(0, days));
          });
          setAvgDaysMap(next);
        }
      }
    } catch {
      setRankings([]);
      setCursor(undefined);
      setHasMore(false);
      setAvgDaysMap(new Map());
    }
  };

  const loadMore = async () => {
    if (loadingMore || !hasMore) return;
    if (activeTab !== "all") return;
    setLoadingMore(true);
    try {
      const { items, nextCursor } = await RankingService.getUserRankingsPage(PAGE_SIZE, cursor);
      const offset = rankings.length;
      items.forEach((r, i) => (r.rank = offset + i + 1));
      const mergedIds = new Set(rankings.map((r) => r.id));
      const dedup = [...rankings];
      for (const r of items) {
        if (!mergedIds.has(r.id)) dedup.push(r);
      }
      setRankings(dedup);
      setCursor(nextCursor);
      setHasMore(Boolean(nextCursor));
      setAvgDaysMap((prev) => {
        const next = new Map(prev);
        items.forEach((r) => {
          const days = Math.floor((r.averageTime || 0) / (24 * 60 * 60));
          next.set(r.id, Math.max(0, days));
        });
        return next;
      });
    } finally {
      setLoadingMore(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await refreshRankings();
    setRefreshing(false);
  };

  const getCurrentUserRank = () => {
    if (!user || rankings.length === 0) return null;
    const currentUserRanking = rankings.find(
      (ranking) => ranking.id === user.uid,
    );
    return currentUserRanking ? currentUserRanking.rank : null;
  };

  const getRankIcon = (rank: number) => {
    switch (rank) {
      case 1:
        return "trophy";
      case 2:
        return "medal";
      case 3:
        return "medal-outline";
      default:
        return "person";
    }
  };

  const getRankColor = (rank: number) => {
    switch (rank) {
      case 1:
        return "#F59E0B";
      case 2:
        return "#6B7280";
      case 3:
        return "#9CA3AF";
      default:
        return "#111827";
    }
  };

  const handleUserPress = (
    userId: string,
    userName: string,
    userAvatar?: string,
  ) => {
    navigateToUserDetail(navigation, userId, userName, userAvatar);
  };

  const onUserPress = useCallback(
    (userId: string, userName: string, userAvatar?: string) => {
      navigateToUserDetail(navigation, userId, userName, userAvatar);
    },
    [navigation],
  );

  const renderRankingItem = useCallback(
    ({ item }: { item: UserRanking }) => (
      <RankingListItem
        item={item}
        avgDays={avgDaysMap.get(item.id) ?? 0}
        currentUserId={user?.uid}
        onPress={onUserPress}
      />
    ),
    [avgDaysMap, user?.uid, onUserPress],
  );

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => {
            navigation.goBack();
          }}
        >
          <Ionicons name="arrow-back" size={24} color={"#111827"} />
        </TouchableOpacity>
        <Text style={styles.title}>ランキング</Text>
        <View style={styles.placeholder} />
      </View>

      {/* タブ切り替え */}
      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "all" && uiStyles.tabActive]}
          onPress={() => {
            if (activeTab !== "all") setActiveTab("all");
          }}
        >
          <Text style={[uiStyles.tabText, activeTab === "all" && uiStyles.tabTextActive]}>全体</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, activeTab === "following" && uiStyles.tabActive]}
          onPress={() => {
            if (activeTab !== "following") setActiveTab("following");
          }}
        >
          <Text style={[uiStyles.tabText, activeTab === "following" && uiStyles.tabTextActive]}>フォロー</Text>
        </TouchableOpacity>
      </View>

      <FlatList
        style={styles.content}
        data={rankings}
        renderItem={renderRankingItem}
        keyExtractor={(item) => item.id}
        onEndReachedThreshold={0.5}
        onEndReached={() => { void loadMore(); }}
        removeClippedSubviews
        windowSize={5}
        maxToRenderPerBatch={24}
        initialNumToRender={12}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={() => {
              void handleRefresh();
            }}
            colors={["#2563EB"]}
            tintColor={"#2563EB"}
          />
        }
        ListFooterComponent={
          loadingMore ? (
            <View style={{ padding: 16, alignItems: "center" }}>
              <Text style={{ color: "#6B7280" }}>読み込み中...</Text>
            </View>
          ) : null
        }
        ListHeaderComponent={
          <View style={styles.descriptionCard}>
            <View style={styles.descriptionHeader}>
              <Ionicons name="trophy" size={24} color={"#F59E0B"} />
              <Text style={styles.descriptionTitle}>ランキング</Text>
              <TouchableOpacity
                onPress={() => setShowTiers((v) => !v)}
                style={{ marginLeft: 'auto' }}
              >
                <Text style={{ color: '#2563EB', fontWeight: '600' }}>
                  {showTiers ? '説明を非表示' : '説明を表示'}
                </Text>
              </TouchableOpacity>
            </View>
            <Text style={styles.descriptionText}>
              現在の継続時間でランキングしています。
            </Text>
            {showTiers && (
            <View style={styles.tierCard}>
              <Text style={styles.tierTitle}>階級について</Text>
              <Text style={styles.tierText}>
                禁欲の現在の継続日数（挑戦中の記録）に応じて階級（称号）が上がります。目安は以下の通りです。
              </Text>
              <ScrollView
                style={styles.tierScrollView}
                showsVerticalScrollIndicator={false}
              >
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>訓練兵 🔰</Text>
                  <Text style={styles.tierRule}>
                    0日: 禁欲のスタート地点。まずは1日から始めましょう。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>二等兵 🔰⭐</Text>
                  <Text style={styles.tierRule}>
                    1日: 初回の達成。習慣化への第一歩です。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>一等兵 🔰⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    2日: 少しずつ習慣が身についてきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>上等兵 🔰⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    3〜6日: 1週間を目指す段階。体調の変化を感じ始めます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>兵長 🪙</Text>
                  <Text style={styles.tierRule}>
                    7〜13日: 1週間達成！安定期に入り、集中力が向上します。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>伍長 🛡️⭐</Text>
                  <Text style={styles.tierRule}>
                    14〜20日: 2週間を超えて、生活リズムが整ってきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>軍曹 🛡️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    21〜29日: 3週間達成。習慣が定着し、自信がついてきます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>軍長 🛡️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    30〜39日: 1ヶ月達成！体調と集中力の変化を強く実感します。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>准尉 🎗️</Text>
                  <Text style={styles.tierRule}>
                    40〜49日: 長期継続の段階。周囲にも良い影響を与え始めます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>少尉 🎖️⭐</Text>
                  <Text style={styles.tierRule}>
                    50〜59日:
                    2ヶ月近く継続。意思決定がクリアになり、判断力が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中尉 🎖️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    60〜69日: 2ヶ月達成！反射的な衝動が弱まり、自制心が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大尉 🎖️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    70〜99日: 3ヶ月近く継続。生活が整い、目標達成能力が向上。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>少佐 🏆⭐</Text>
                  <Text style={styles.tierRule}>
                    100〜149日:
                    100日達成！継続は最強の資産。ロールモデル的存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中佐 🏆⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    150〜199日: 5ヶ月継続。周囲の行動にも好影響を与える存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大佐 🏆⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    200〜299日:
                    半年以上継続。継続力が人生のあらゆる面で活かされます。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>小将 🏵️⭐</Text>
                  <Text style={styles.tierRule}>
                    300〜399日: 10ヶ月継続。禁欲の達人として尊敬される存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>中将 🏵️⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    400〜499日: 1年以上継続。継続の真の価値を理解した存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>大将 🏵️⭐⭐⭐</Text>
                  <Text style={styles.tierRule}>
                    500〜999日: 1年半以上継続。継続の神として崇められる存在。
                  </Text>
                </View>
                <View style={styles.tierItem}>
                  <Text style={styles.tierBadge}>ナポレオン 👑</Text>
                  <Text style={styles.tierRule}>
                    1000日以上:
                    3年近く継続。伝説的存在。継続の皇帝として永遠に語り継がれる。
                  </Text>
                </View>
              </ScrollView>
              <Text style={styles.tierNote}>
                階級は「現在の継続日数（挑戦中の記録）」から算出されます。停止・失敗で継続日数はリセットされますが、次の挑戦で少しずつ押し上げましょう。
              </Text>
            </View>
            )}
            {(() => {
              const currentUserRank = getCurrentUserRank();
              if (currentUserRank) {
                return (
                  <Text style={styles.currentUserRank}>
                    あなたの順位: {rankings.length}人中{currentUserRank}位
                  </Text>
                );
              } else {
                return (
                  <Text style={styles.participantCount}>
                    参加者: {rankings.length}人
                  </Text>
                );
              }
            })()}
          </View>
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons name="trophy-outline" size={64} color={"#9CA3AF"} />
            <Text style={styles.emptyTitle}>ランキングデータがありません</Text>
            <Text style={styles.emptyText}>
              {activeTab === 'following' ? 'フォローしているユーザーに対象者がいません' : 'チャレンジを完了したユーザーがいるとランキングが表示されます'}
            </Text>
          </View>
        }
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#F5F5F7",
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: "#FFFFFF",
    borderBottomWidth: 1,
    borderBottomColor: "#E5E7EB",
  },
  backButton: {
    padding: 8,
  },
  title: {
    fontSize: 20,
    fontWeight: "700",
    color: "#111827",
    textAlign: "center",
    flex: 1,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  descriptionCard: {
    backgroundColor: "#FEF3C7",
    margin: 16,
    borderRadius: 16,
    padding: 16,
  },
  descriptionHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
  },
  descriptionTitle: {
    fontSize: 18,
    fontWeight: "600",
    color: "#111827",
    marginLeft: 8,
  },
  descriptionText: {
    fontSize: 14,
    color: "#6B7280",
    lineHeight: 14 * 1.5,
  },
  tierCard: {
    backgroundColor: "#FFFFFF",
    borderRadius: 12,
    padding: 12,
    marginTop: 12,
    borderWidth: 1,
    borderColor: "#FDE68A",
    maxHeight: 400,
  },
  tierTitle: {
    fontSize: 16,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 8,
  },
  tierText: {
    fontSize: 13,
    color: "#6B7280",
    marginBottom: 8,
    lineHeight: 18,
  },
  tierScrollView: {
    maxHeight: 300,
  },
  tierItem: {
    marginBottom: 8,
  },
  tierBadge: {
    backgroundColor: "#E0F2FE",
    color: "#0369A1",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
    fontSize: 13,
    fontWeight: "700",
    marginBottom: 4,
    alignSelf: "flex-start",
  },
  tierRule: {
    fontSize: 13,
    color: "#374151",
    lineHeight: 18,
    marginLeft: 4,
  },
  tierNote: {
    marginTop: 8,
    fontSize: 12,
    color: "#6B7280",
  },
  participantCount: {
    fontSize: 14,
    color: "#6B7280",
    marginTop: 4,
    fontWeight: "500",
  },
  currentUserRank: {
    fontSize: 14,
    color: "#111827",
    marginTop: 4,
    fontWeight: "700",
  },
  rankingItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#FFFFFF",
    marginHorizontal: 16,
    marginVertical: 4,
    padding: 16,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOpacity: 0.05,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    position: "relative",
  },
  currentUserItem: {
    backgroundColor: "#FFFFFF",
    borderWidth: 2,
    borderColor: "#2563EB",
  },
  youBadgeContainer: {
    position: "absolute",
    top: -12,
    left: -6,
    backgroundColor: "#2563EB",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    zIndex: 2,
  },
  youBadgeText: {
    color: "#FFFFFF",
    fontSize: 12,
    fontWeight: "700",
  },
  rankContainer: {
    alignItems: "center",
    marginRight: 16,
    minWidth: 40,
  },
  userProfileContainer: {
    marginRight: 8,
  },
  rankNumber: {
    fontSize: 14,
    fontWeight: "700",
    marginTop: 4,
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 16,
    fontWeight: "600",
    color: "#111827",
    marginBottom: 4,
  },
  currentUserName: {
    color: "#111827",
    fontWeight: "700",
  },
  currentUserText: {
    color: "#111827",
  },
  averageTimeContainer: {
    marginBottom: 4,
  },
  averageTime: {
    fontSize: 14,
    color: "#6B7280",
    fontWeight: "500",
  },
  averageTimeSub: {
    fontSize: 14,
    color: "#9CA3AF",
    marginTop: 2,
    fontWeight: "500",
  },
  stats: {
    fontSize: 12,
    color: "#9CA3AF",
  },
  emptyContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 32,
    paddingHorizontal: 16,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: "600",
    color: "#6B7280",
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    color: "#9CA3AF",
    textAlign: "center",
    lineHeight: 14 * 1.5,
  },
});

export default RankingScreen;

*** Update File: src/features/profile/screens/BlockedUsersScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useEffect, useMemo, useState } from "react";
import {
  SafeAreaView,
  StatusBar,
  StyleSheet,
  View,
  FlatList,
  TouchableOpacity,
  Text,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import { BlockService } from "@core/services/firestore";
import UserProfileWithRank from "@shared/components/UserProfileWithRank";
import { colors, spacing, typography } from "@shared/theme";
import { navigateToUserDetail } from "@shared/utils/navigation";

export interface SimpleUser {
  id: string;
  displayName: string;
  photoURL?: string;
}

const BlockedUsersScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation<StackNavigationProp<RootStackParamList>>();
  const [blockedIds, setBlockedIds] = useState<Set<string>>(new Set());
  const [users, setUsers] = useState<SimpleUser[]>([]);

  useEffect(() => {
    if (!user?.uid) return;
    const unsub = BlockService.subscribeBlockedIds(user.uid, (ids) => {
      setBlockedIds(new Set(ids));
    });
    return unsub;
  }, [user?.uid]);

  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      try {
        const { FirestoreUserService } = await import(
          "@core/services/firestore"
        );
        const list: SimpleUser[] = [];
        for (const id of blockedIds) {
          try {
            const u = await FirestoreUserService.getUserById(id);
            if (u)
              list.push({
                id,
                displayName: u.displayName || "ユーザー",
                photoURL: u.photoURL ?? undefined,
              });
          } catch {}
        }
        if (!cancelled) setUsers(list);
      } catch {}
    };
    void load();
    return () => {
      cancelled = true;
    };
  }, [blockedIds]);

  const empty = useMemo(
    () => (
      <View style={styles.emptyContainer}>
        <Text style={styles.emptyText}>ブロック中のユーザーはいません</Text>
      </View>
    ),
    [],
  );

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{ padding: spacing.sm }}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>ブロック中のユーザー</Text>
        <View style={{ width: 22 }} />
      </View>
      <FlatList
        data={users}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        renderItem={({ item }) => (
          <TouchableOpacity
            activeOpacity={0.8}
            style={styles.item}
            onPress={() =>
              navigateToUserDetail(
                navigation as any,
                item.id,
                item.displayName,
                item.photoURL ?? undefined,
              )
            }
          >
            <UserProfileWithRank
              userName={item.displayName}
              userAvatar={item.photoURL}
              averageDays={0}
              size="small"
              showRank={false}
              showTitle={false}
            />
          </TouchableOpacity>
        )}
        ListEmptyComponent={empty}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
    flexDirection: "row",
    alignItems: "center",
  },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  listContent: {
    padding: spacing.lg,
  },
  item: {
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.lg,
    marginBottom: spacing.md,
  },
  emptyContainer: {
    padding: spacing.xl,
    alignItems: "center",
  },
  emptyText: {
    color: colors.textSecondary,
  },
});

export default BlockedUsersScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useEffect, useMemo, useState } from "react";
import {
  SafeAreaView,
  StatusBar,
  StyleSheet,
  View,
  FlatList,
  TouchableOpacity,
  Text,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import { BlockService } from "@core/services/firestore";
import UserProfileWithRank from "@shared/components/UserProfileWithRank";
import { colors, spacing, typography } from "@shared/theme";
import { navigateToUserDetail } from "@shared/utils/navigation";

export interface SimpleUser {
  id: string;
  displayName: string;
  photoURL?: string;
}

const BlockedUsersScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation<StackNavigationProp<RootStackParamList>>();
  const [blockedIds, setBlockedIds] = useState<Set<string>>(new Set());
  const [users, setUsers] = useState<SimpleUser[]>([]);

  useEffect(() => {
    if (!user?.uid) return;
    const unsub = BlockService.subscribeBlockedIds(user.uid, (ids) => {
      setBlockedIds(new Set(ids));
    });
    return unsub;
  }, [user?.uid]);

  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      try {
        const { FirestoreUserService } = await import(
          "@core/services/firestore"
        );
        const list: SimpleUser[] = [];
        for (const id of blockedIds) {
          try {
            const u = await FirestoreUserService.getUserById(id);
            if (u)
              list.push({
                id,
                displayName: u.displayName || "ユーザー",
                photoURL: u.photoURL ?? undefined,
              });
          } catch {}
        }
        if (!cancelled) setUsers(list);
      } catch {}
    };
    void load();
    return () => {
      cancelled = true;
    };
  }, [blockedIds]);

  const empty = useMemo(
    () => (
      <View style={styles.emptyContainer}>
        <Text style={styles.emptyText}>ブロック中のユーザーはいません</Text>
      </View>
    ),
    [],
  );

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{ padding: spacing.sm }}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>ブロック中のユーザー</Text>
        <View style={{ width: 22 }} />
      </View>
      <FlatList
        data={users}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        renderItem={({ item }) => (
          <TouchableOpacity
            activeOpacity={0.8}
            style={styles.item}
            onPress={() =>
              navigateToUserDetail(
                navigation as any,
                item.id,
                item.displayName,
                item.photoURL ?? undefined,
              )
            }
          >
            <UserProfileWithRank
              userName={item.displayName}
              userAvatar={item.photoURL}
              averageDays={0}
              size="small"
              showRank={false}
              showTitle={false}
            />
          </TouchableOpacity>
        )}
        ListEmptyComponent={empty}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
    flexDirection: "row",
    alignItems: "center",
  },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  listContent: {
    padding: spacing.lg,
  },
  item: {
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.lg,
    marginBottom: spacing.md,
  },
  emptyContainer: {
    padding: spacing.xl,
    alignItems: "center",
  },
  emptyText: {
    color: colors.textSecondary,
  },
});

export default BlockedUsersScreen;

*** Update File: src/features/feedback/screens/FeedbackScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import React, { useMemo, useState, useCallback } from "react";
import {
  SafeAreaView,
  StatusBar,
  StyleSheet,
  View,
  TextInput,
  Text,
  Platform,
  TouchableOpacity,
  Alert,
  Linking,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import Button from "@shared/components/Button";
import { colors, spacing, typography } from "@shared/theme";
import * as MailComposer from "expo-mail-composer";

const FeedbackScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [subject, setSubject] = useState("");
  const [message, setMessage] = useState("");
  const [sending, setSending] = useState(false);
  const [sent, setSent] = useState(false);
  // 送信先メールアドレス（EXPO_PUBLIC_FEEDBACK_EMAIL があれば優先）
  const FEEDBACK_EMAIL =
    (process.env.EXPO_PUBLIC_FEEDBACK_EMAIL as string | undefined) ||
    "support@example.com"; // TODO: 本番用に置き換え/環境変数で設定

  const canSend = useMemo(
    () => subject.trim().length > 0 && message.trim().length > 0,
    [subject, message],
  );

  const doSubmit = useCallback(async () => {
    if (!canSend || sending) return;
    setSending(true);
    try {
      const subj = subject.trim();
      const body = `${message.trim()}\n\n---\nPlatform: ${Platform.OS} ${Platform.Version}`;

      // 1) Expo MailComposer（対応端末）
      const available = await MailComposer.isAvailableAsync();
      if (available) {
        const result = await MailComposer.composeAsync({
          recipients: [FEEDBACK_EMAIL],
          subject: subj,
          body,
        });
        if (result.status === MailComposer.MailComposerStatus.SENT) {
          setSent(true);
          setSubject("");
          setMessage("");
          Alert.alert("送信完了", "メールアプリから送信しました。ありがとうございます！");
          return;
        }
        // cancelled などの場合も特にエラーにはしない
        return;
      }

      // 2) Web/未対応端末: mailto にフォールバック
      const url = `mailto:${FEEDBACK_EMAIL}?subject=${encodeURIComponent(
        subj,
      )}&body=${encodeURIComponent(body)}`;
      const canOpen = await Linking.canOpenURL(url);
      if (canOpen) {
        await Linking.openURL(url);
        setSent(true);
        return;
      }

      Alert.alert("エラー", "端末のメール機能にアクセスできませんでした。");
    } catch (e: any) {
      console.error("Feedback mail compose failed:", e);
      Alert.alert("エラー", "メールの作成に失敗しました: " + e.message);
    } finally {
      setSending(false);
    }
  }, [canSend, sending, subject, message]);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{ padding: spacing.sm }}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>フィードバック</Text>
        <View style={{ width: 22 }} />
      </View>
      <View style={styles.form}>
        <Text style={styles.label}>件名</Text>
        <TextInput
          placeholder="例: 目標日数の選択UIについて"
          placeholderTextColor={colors.textSecondary}
          value={subject}
          onChangeText={setSubject}
          style={styles.input}
        />
        <Text style={[styles.label, { marginTop: spacing.lg }]}>内容</Text>
        <TextInput
          placeholder="できるだけ具体的にご記入ください"
          placeholderTextColor={colors.textSecondary}
          value={message}
          onChangeText={setMessage}
          style={[styles.input, styles.textarea]}
          multiline
          textAlignVertical="top"
        />
        <View style={{ height: spacing.lg }} />
        <Button
          title={sent ? "送信しました" : "メールで送信"}
          onPress={() => { void doSubmit(); }}
          disabled={!canSend || sent}
          loading={sending}
        />
        {sent && (
          <Text style={styles.successMessage}>
            ✅ フィードバックを送信しました。ありがとうございます！
          </Text>
        )}
      </View>

      {/* Auth modal is handled globally by AuthPromptProvider */}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
    flexDirection: "row",
    alignItems: "center",
  },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  subTitle: {
    marginTop: 4,
    color: colors.textSecondary,
  },
  form: {
    padding: spacing.lg,
  },
  label: {
    fontSize: typography.fontSize.sm,
    color: colors.gray800,
    fontWeight: "600",
  },
  input: {
    marginTop: 6,
    backgroundColor: colors.white,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    color: colors.gray800,
  },
  textarea: {
    minHeight: 160,
  },
  successMessage: {
    marginTop: spacing.md,
    textAlign: "center",
    color: colors.success,
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
  },
});

export default FeedbackScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import React, { useMemo, useState, useCallback } from "react";
import {
  SafeAreaView,
  StatusBar,
  StyleSheet,
  View,
  TextInput,
  Text,
  Platform,
  TouchableOpacity,
  Alert,
  Linking,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import Button from "@shared/components/Button";
import { colors, spacing, typography } from "@shared/theme";
import * as MailComposer from "expo-mail-composer";

const FeedbackScreen: React.FC = () => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [subject, setSubject] = useState("");
  const [message, setMessage] = useState("");
  const [sending, setSending] = useState(false);
  const [sent, setSent] = useState(false);
  // 送信先メールアドレス（EXPO_PUBLIC_FEEDBACK_EMAIL があれば優先）
  const FEEDBACK_EMAIL =
    (process.env.EXPO_PUBLIC_FEEDBACK_EMAIL as string | undefined) ||
    "support@example.com"; // TODO: 本番用に置き換え/環境変数で設定

  const canSend = useMemo(
    () => subject.trim().length > 0 && message.trim().length > 0,
    [subject, message],
  );

  const doSubmit = useCallback(async () => {
    if (!canSend || sending) return;
    setSending(true);
    try {
      const subj = subject.trim();
      const body = `${message.trim()}\n\n---\nPlatform: ${Platform.OS} ${Platform.Version}`;

      // 1) Expo MailComposer（対応端末）
      const available = await MailComposer.isAvailableAsync();
      if (available) {
        const result = await MailComposer.composeAsync({
          recipients: [FEEDBACK_EMAIL],
          subject: subj,
          body,
        });
        if (result.status === MailComposer.MailComposerStatus.SENT) {
          setSent(true);
          setSubject("");
          setMessage("");
          Alert.alert("送信完了", "メールアプリから送信しました。ありがとうございます！");
          return;
        }
        // cancelled などの場合も特にエラーにはしない
        return;
      }

      // 2) Web/未対応端末: mailto にフォールバック
      const url = `mailto:${FEEDBACK_EMAIL}?subject=${encodeURIComponent(
        subj,
      )}&body=${encodeURIComponent(body)}`;
      const canOpen = await Linking.canOpenURL(url);
      if (canOpen) {
        await Linking.openURL(url);
        setSent(true);
        return;
      }

      Alert.alert("エラー", "端末のメール機能にアクセスできませんでした。");
    } catch (e: any) {
      console.error("Feedback mail compose failed:", e);
      Alert.alert("エラー", "メールの作成に失敗しました: " + e.message);
    } finally {
      setSending(false);
    }
  }, [canSend, sending, subject, message]);

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{ padding: spacing.sm }}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>フィードバック</Text>
        <View style={{ width: 22 }} />
      </View>
      <View style={styles.form}>
        <Text style={styles.label}>件名</Text>
        <TextInput
          placeholder="例: 目標日数の選択UIについて"
          placeholderTextColor={colors.textSecondary}
          value={subject}
          onChangeText={setSubject}
          style={styles.input}
        />
        <Text style={[styles.label, { marginTop: spacing.lg }]}>内容</Text>
        <TextInput
          placeholder="できるだけ具体的にご記入ください"
          placeholderTextColor={colors.textSecondary}
          value={message}
          onChangeText={setMessage}
          style={[styles.input, styles.textarea]}
          multiline
          textAlignVertical="top"
        />
        <View style={{ height: spacing.lg }} />
        <Button
          title={sent ? "送信しました" : "メールで送信"}
          onPress={() => { void doSubmit(); }}
          disabled={!canSend || sent}
          loading={sending}
        />
        {sent && (
          <Text style={styles.successMessage}>
            ✅ フィードバックを送信しました。ありがとうございます！
          </Text>
        )}
      </View>

      {/* Auth modal is handled globally by AuthPromptProvider */}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
    flexDirection: "row",
    alignItems: "center",
  },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  subTitle: {
    marginTop: 4,
    color: colors.textSecondary,
  },
  form: {
    padding: spacing.lg,
  },
  label: {
    fontSize: typography.fontSize.sm,
    color: colors.gray800,
    fontWeight: "600",
  },
  input: {
    marginTop: 6,
    backgroundColor: colors.white,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    color: colors.gray800,
  },
  textarea: {
    minHeight: 160,
  },
  successMessage: {
    marginTop: spacing.md,
    textAlign: "center",
    color: colors.success,
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
  },
});

export default FeedbackScreen;

*** Update File: src/features/community/components/CreatePostModal.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  Alert,
  TextInput,
  TouchableOpacity,
  Modal as RNModal,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  StatusBar,
} from "react-native";

import { useModerationGuard } from "@shared/hooks/useModerationGuard";
import { colors, spacing, typography } from "@shared/theme";
import uiStyles from "@shared/ui/styles";

interface CreatePostModalProps {
  visible: boolean;
  onClose: () => void;
  onSubmit: (post: { content: string }) => void;
}

const CreatePostModal: React.FC<CreatePostModalProps> = ({
  visible,
  onClose,
  onSubmit,
}) => {
  const [content, setContent] = useState("");
  const guard = useModerationGuard(content);

  const handleSubmit = () => {
    if (!content.trim() || !guard.canSend) {
      Alert.alert("エラー", "投稿内容を入力してください");
      return;
    }

    onSubmit({
      content: content.trim(),
    });

    setContent("");
    onClose();
  };

  const handleClose = () => {
    setContent("");
    onClose();
  };

  return (
    <RNModal
      visible={visible}
      animationType="slide"
      transparent={false}
      onRequestClose={handleClose}
      statusBarTranslucent
    >
      <SafeAreaView style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor={colors.white} />
        <View style={[uiStyles.row, styles.header]}>
          <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
            <Ionicons name="close" size={24} color={colors.textPrimary} />
          </TouchableOpacity>
        </View>

        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={styles.keyboardAvoidingView}
        >
          <View style={styles.content}>
            <TextInput
              style={styles.textInput}
              placeholder="今何をしていますか？"
              placeholderTextColor={colors.textSecondary}
              value={content}
              onChangeText={setContent}
              multiline
              maxLength={280}
              autoFocus
            />

            <View style={[uiStyles.rowBetween, styles.footer]}>
              <View style={styles.counterContainer}>
                <Text
                  style={[
                    styles.counter,
                    content.length > 260 && styles.counterWarning,
                  ]}
                >
                  {content.length}/280
                </Text>
              </View>
              <TouchableOpacity
                onPress={handleSubmit}
                style={[
                  styles.postButton,
                  !content.trim() && styles.postButtonDisabled,
                ]}
                disabled={!content.trim()}
              >
                <Text
                  style={[
                    styles.postButtonText,
                    !content.trim() && styles.postButtonTextDisabled,
                  ]}
                >
                  投稿
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </RNModal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.white,
  },
  header: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  closeButton: {
    padding: spacing.sm,
    borderRadius: 20,
    backgroundColor: colors.gray100,
  },
  content: {
    flex: 1,
    padding: spacing.xl,
  },
  footer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: spacing.lg,
  },
  postButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.md,
    borderRadius: 25,
    minWidth: 80,
    alignItems: "center",
  },
  postButtonDisabled: {
    backgroundColor: colors.gray300,
  },
  postButtonText: {
    color: colors.white,
    fontSize: typography.fontSize.base,
    fontWeight: "600",
  },
  postButtonTextDisabled: {
    color: colors.gray500,
  },
  textInput: {
    fontSize: typography.fontSize.lg,
    color: colors.textPrimary,
    minHeight: 200,
    textAlignVertical: "top",
    lineHeight: 26,
    backgroundColor: colors.gray50,
    borderRadius: 12,
    padding: spacing.lg,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    flex: 1,
  },
  counterContainer: {
    alignItems: "flex-end",
  },
  counter: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium,
  },
  counterWarning: {
    color: colors.warning,
  },
});

export default CreatePostModal;

+import { Ionicons } from "@expo/vector-icons";
import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  Alert,
  TextInput,
  TouchableOpacity,
  Modal as RNModal,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  StatusBar,
} from "react-native";

import { useModerationGuard } from "@shared/hooks/useModerationGuard";
import { colors, spacing, typography } from "@shared/theme";
import uiStyles from "@shared/ui/styles";

interface CreatePostModalProps {
  visible: boolean;
  onClose: () => void;
  onSubmit: (post: { content: string }) => void;
}

const CreatePostModal: React.FC<CreatePostModalProps> = ({
  visible,
  onClose,
  onSubmit,
}) => {
  const [content, setContent] = useState("");
  const guard = useModerationGuard(content);

  const handleSubmit = () => {
    if (!content.trim() || !guard.canSend) {
      Alert.alert("エラー", "投稿内容を入力してください");
      return;
    }

    onSubmit({
      content: content.trim(),
    });

    setContent("");
    onClose();
  };

  const handleClose = () => {
    setContent("");
    onClose();
  };

  return (
    <RNModal
      visible={visible}
      animationType="slide"
      transparent={false}
      onRequestClose={handleClose}
      statusBarTranslucent
    >
      <SafeAreaView style={styles.container}>
        <AppStatusBar />
        <View style={[uiStyles.row, styles.header]}>
          <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
            <Ionicons name="close" size={24} color={colors.textPrimary} />
          </TouchableOpacity>
        </View>

        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={styles.keyboardAvoidingView}
        >
          <View style={styles.content}>
            <TextInput
              style={styles.textInput}
              placeholder="今何をしていますか？"
              placeholderTextColor={colors.textSecondary}
              value={content}
              onChangeText={setContent}
              multiline
              maxLength={280}
              autoFocus
            />

            <View style={[uiStyles.rowBetween, styles.footer]}>
              <View style={styles.counterContainer}>
                <Text
                  style={[
                    styles.counter,
                    content.length > 260 && styles.counterWarning,
                  ]}
                >
                  {content.length}/280
                </Text>
              </View>
              <TouchableOpacity
                onPress={handleSubmit}
                style={[
                  styles.postButton,
                  !content.trim() && styles.postButtonDisabled,
                ]}
                disabled={!content.trim()}
              >
                <Text
                  style={[
                    styles.postButtonText,
                    !content.trim() && styles.postButtonTextDisabled,
                  ]}
                >
                  投稿
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </RNModal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.white,
  },
  header: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  closeButton: {
    padding: spacing.sm,
    borderRadius: 20,
    backgroundColor: colors.gray100,
  },
  content: {
    flex: 1,
    padding: spacing.xl,
  },
  footer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: spacing.lg,
  },
  postButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.md,
    borderRadius: 25,
    minWidth: 80,
    alignItems: "center",
  },
  postButtonDisabled: {
    backgroundColor: colors.gray300,
  },
  postButtonText: {
    color: colors.white,
    fontSize: typography.fontSize.base,
    fontWeight: "600",
  },
  postButtonTextDisabled: {
    color: colors.gray500,
  },
  textInput: {
    fontSize: typography.fontSize.lg,
    color: colors.textPrimary,
    minHeight: 200,
    textAlignVertical: "top",
    lineHeight: 26,
    backgroundColor: colors.gray50,
    borderRadius: 12,
    padding: spacing.lg,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    flex: 1,
  },
  counterContainer: {
    alignItems: "flex-end",
  },
  counter: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium,
  },
  counterWarning: {
    color: colors.warning,
  },
});

export default CreatePostModal;

*** Update File: src/features/tournaments/screens/TournamentRoomScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useState, useEffect, useRef } from "react";
import {
  Alert,
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  FlatList,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import {
  TournamentService,
  handleFirestoreError,
} from "@core/services/firestore";
import UserService from "@core/services/userService";
import { UserStatsService } from "@core/services/userStatsService";
import MessageBubble from "@features/tournaments/components/MessageBubble";
import MessageInput from "@features/tournaments/components/MessageInput";
import Button from "@shared/components/Button";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import KeyboardAwareScrollView from "@shared/components/KeyboardAwareScrollView";
import UserProfileWithRank from "@shared/components/UserProfileWithRank";
import { useDisplayProfile } from "@shared/hooks/useDisplayProfile";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { toDate } from "@shared/utils/date";
import { navigateToUserDetail } from "@shared/utils/navigation";

type TournamentRoomScreenNavigationProp = StackNavigationProp<
  TournamentStackParamList,
  "TournamentRoom"
>;

interface Message {
  id: string;
  authorId: string;
  authorName: string;
  text: string;
  timestamp: Date;
  type: "text" | "system";
  avatar?: string;
}

interface Participant {
  id: string;
  name: string;
  avatar?: string;
  role: "owner" | "member";
  status: "joined" | "left" | "kicked" | "completed" | "failed";
  progressPercent?: number;
  currentDay?: number;
}

interface JoinRequest {
  id: string;
  userId: string;
  userName: string;
  userAvatar?: string;
}

interface TournamentRoomScreenProps {
  route: {
    params: {
      tournamentId: string;
    };
  };
}

const TournamentRoomScreen: React.FC<TournamentRoomScreenProps> = ({
  route,
}) => {
  const navigation = useNavigation<TournamentRoomScreenNavigationProp>();
  const { tournamentId } = route.params;
  const [activeTab, setActiveTab] = useState<"chat" | "participants">("chat");
  const { user } = useAuth();

  // チャットメッセージ
  const [messages, setMessages] = useState<Message[]>([]);
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [tournament, setTournament] = useState<{ ownerId?: string } | null>(
    null,
  );
  const [joinRequests, setJoinRequests] = useState<JoinRequest[]>([]);
  // const [loading, setLoading] = useState(true);
  const [userAverageDays, setUserAverageDays] = useState<Map<string, number>>(
    new Map(),
  );

  // スクロール制御
  const listRef = useRef<FlatList<Message>>(null);
  const [initialScrolled, setInitialScrolled] = useState(false);
  // チャットは常に最新が最下部になるよう inverted を使用

  // 初期100件 + 新着の随時取得
  useEffect(() => {
    let unsubNew: undefined | (() => void);
    let cancelled = false;
    (async () => {
      try {
        // 最新から100件取得（desc）→ asc に並べ替えて状態に保存
        const { items, nextCursor } = await TournamentService.getRecentMessages(
          tournamentId,
          100,
        );
        const latestDesc = items; // already desc (newest first)
        if (cancelled) return;
        setMessages(
          latestDesc.map((msg) => ({
            id: msg.id,
            authorId: msg.authorId,
            authorName: msg.authorName,
            text: msg.text,
            timestamp: toDate(msg.createdAt),
            type: msg.type,
            avatar: msg.authorAvatar,
          })),
        );
        // 新着を購読（最新のcreatedAt以降）
        const latestTs = latestDesc[0]?.createdAt as any;
        if (latestTs) {
          unsubNew = TournamentService.subscribeToNewMessages(
            tournamentId,
            latestTs,
            (news) => {
              if (!news || news.length === 0) return;
              setMessages((prev) => {
                const existing = new Set(prev.map((p) => p.id));
                // news is asc; convert to desc and put at start
                const appended = [...news]
                  .reverse()
                  .map((msg) => ({
                    id: msg.id,
                    authorId: msg.authorId,
                    authorName: msg.authorName,
                    text: msg.text,
                    timestamp: toDate(msg.createdAt),
                    type: msg.type,
                    avatar: msg.authorAvatar,
                  }))
                  .filter((m) => !existing.has(m.id));
                if (appended.length === 0) return prev;
                return [...appended, ...prev];
              });
            },
          );
        }
        // keep cursor for older loads
        setOlderCursor(nextCursor);
      } catch (e) {
        console.warn("failed to init chat messages:", e);
      }
    })();
    return () => {
      cancelled = true;
      if (unsubNew) unsubNew();
    };
  }, [tournamentId]);

  const [olderCursor, setOlderCursor] = useState<any | undefined>(undefined);
  const [loadingMore, setLoadingMore] = useState(false);
  const loadOlder = async () => {
    if (loadingMore || !olderCursor) return;
    setLoadingMore(true);
    try {
      const { items, nextCursor } = await TournamentService.getRecentMessages(
        tournamentId,
        50,
        olderCursor,
      );
      // items are older (desc). Keep desc and append to tail
      const olderDesc = items.map((msg) => ({
        id: msg.id,
        authorId: msg.authorId,
        authorName: msg.authorName,
        text: msg.text,
        timestamp: toDate(msg.createdAt),
        type: msg.type,
        avatar: msg.authorAvatar,
      }));
      setMessages((prev) => [...prev, ...olderDesc]);
      setOlderCursor(nextCursor);
    } finally {
      setLoadingMore(false);
    }
  };

  // 大会情報と参加者の購読
  useEffect(() => {
    let unsubscribeParticipants: undefined | (() => void);
    let unsubscribeRequests: undefined | (() => void);
    const init = async () => {
      try {
        const tournamentData =
          await TournamentService.getTournament(tournamentId);
        setTournament(tournamentData);
        // オーナー情報を取得。Firestore優先、なければローカルにフォールバック
        let ownerDisplayName: string | undefined;
        let ownerAvatarUrl: string | undefined;
        try {
          if (tournamentData?.ownerId) {
            const owner = await (
              await import("@core/services/firestore")
            ).FirestoreUserService.getUserById(tournamentData.ownerId);
            ownerDisplayName = owner?.displayName;
            ownerAvatarUrl = owner?.photoURL ?? undefined;
          }
        } catch {
          // noop
        }
        if (!ownerDisplayName) {
          const userService = UserService.getInstance();
          ownerDisplayName =
            tournamentData?.ownerId === user?.uid
              ? user?.displayName || undefined
              : await userService.getUserName();
        }
        if (!ownerAvatarUrl) {
          const userService = UserService.getInstance();
          ownerAvatarUrl =
            tournamentData?.ownerId === user?.uid
              ? user?.avatarUrl || undefined
              : await userService.getAvatarUrl();
        }

        unsubscribeParticipants = TournamentService.subscribeToParticipants(
          tournamentId,
          async (list) => {
            // オーナーが含まれていなければ追加
            const ownerExists = list.some(
              (p) => p.userId === tournamentData?.ownerId,
            );
            const all =
              ownerExists || !tournamentData?.ownerId
                ? list
                : [
                    {
                      id: "owner-participant",
                      tournamentId,
                      userId: tournamentData.ownerId,
                      userName: ownerDisplayName || "ユーザー",
                      userAvatar: ownerAvatarUrl,
                      status: "joined",
                      joinedAt: tournamentData.createdAt,
                      progressPercent: 0,
                      currentDay: 0,
                    },
                    ...list,
                  ];

            const converted: Participant[] = all.map((p) => ({
              id: p.userId,
              name: p.userName,
              avatar: p.userAvatar,
              role: p.userId === tournamentData?.ownerId ? "owner" : "member",
              status: p.status as Participant["status"],
              progressPercent: p.progressPercent,
              currentDay: p.currentDay,
            }));

            setParticipants(converted);

            // 参加者ごとの平均日数を取得
            const averageDaysMap = new Map<string, number>();
            for (const participant of converted) {
              try {
                const days = await UserStatsService.getUserCurrentDaysForRank(
                  participant.id,
                );
                averageDaysMap.set(participant.id, days);
              } catch (error) {
                console.error(
                  "ユーザーの平均日数取得に失敗",
                  participant.id,
                  error,
                );
                averageDaysMap.set(participant.id, 0);
              }
            }
            setUserAverageDays(averageDaysMap);
          },
        );

        // 参加申請の購読（オーナーのみ表示用）
        unsubscribeRequests = TournamentService.subscribeToJoinRequests(
          tournamentId,
          (reqs) => {
            const pending = reqs.filter((r) => r.status === "pending");
            const mapped: JoinRequest[] = pending.map((r) => ({
              id: r.id,
              userId: r.userId,
              userName: r.userName,
              userAvatar: r.userAvatar ?? undefined,
            }));
            setJoinRequests(mapped);
          },
        );
      } catch (e) {
        console.error("トーナメントの参加者取得でエラーが発生しました:", e);
        Alert.alert("エラー", "トーナメントの参加者取得でエラーが発生しました");
      }
    };
    void init();
    return () => {
      if (unsubscribeParticipants) unsubscribeParticipants();
      if (unsubscribeRequests) unsubscribeRequests();
    };
  }, [tournamentId]);

  const handleApprove = async (requestId: string) => {
    try {
      await TournamentService.approveJoinRequest(requestId);
    } catch (e) {
      const err = handleFirestoreError(e);
      setConfirm({
        visible: true,
        title: "エラー",
        message: err.message,
        onConfirm: () => setConfirm({ visible: false }),
      });
    }
  };

  const handleReject = async (requestId: string) => {
    try {
      await TournamentService.rejectJoinRequest(requestId);
    } catch (e) {
      const err = handleFirestoreError(e);
      setConfirm({
        visible: true,
        title: "エラー",
        message: err.message,
        onConfirm: () => setConfirm({ visible: false }),
      });
    }
  };

  const handleSendMessage = async (text: string) => {
    if (!text.trim()) return;

    // 楽観的にメッセージを1件だけ即時追加（他のUIは触らない）
    const localId = `local-${Date.now()}`;
    const optimistic: Message = {
      id: localId,
      authorId: user?.uid || "me",
      authorName: user?.displayName || "あなた",
      text: text.trim(),
      timestamp: new Date(),
      type: "text",
      avatar: user?.avatarUrl || undefined,
    };
    // desc: newest first → 先頭に追加
    setMessages((prev) => [optimistic, ...prev]);

    try {
      // メッセージポートエラー対策のため、タイムアウトを設定
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(
          () => reject(new Error("メッセージ送信がタイムアウトしました")),
          10000,
        );
      });

      const sendPromise = TournamentService.sendMessage(
        tournamentId,
        text.trim(),
      );

      const newId = (await Promise.race([
        sendPromise,
        timeoutPromise,
      ])) as string;
      // サーバIDに置き換え。既に同IDのサーバメッセージが来ていれば重複除去
      setMessages((prev) => {
        const mapped = prev.map((m) =>
          m.id === localId ? { ...m, id: newId } : m,
        );
        const seen = new Set<string>();
        const dedup: Message[] = [];
        for (const m of mapped) {
          if (seen.has(m.id)) continue;
          seen.add(m.id);
          dedup.push(m);
        }
        return dedup;
      });
    } catch (error) {
      // 失敗時は楽観的メッセージを除去
      setMessages((prev) => prev.filter((m) => m.id !== localId));
      console.error("メッセージの送信でエラーが発生しました:", error);

      // メッセージポートエラーの場合の特別な処理
      if (error instanceof Error && error.message.includes("message port")) {
        console.warn(
          "メッセージポートエラーが発生しましたが、メッセージは送信された可能性があります",
        );
        return; // エラーを表示せずに処理を継続
      }

      const firestoreError = handleFirestoreError(error);
      Alert.alert("エラー", firestoreError.message);
    }
  };

  const handleBack = () => {
    navigation.goBack();
  };

  const renderMessage = ({ item }: { item: Message }) => {
    const isOwn = user ? item.authorId === user.uid : false;

    return (
      <MessageBubble
        message={item}
        isOwn={isOwn}
        onUserPress={(uid, uname, uavatar) =>
          navigateToUserDetail(navigation, uid, uname, uavatar)
        }
      />
    );
  };

  const handleParticipantPress = (participant: Participant) => {
    navigateToUserDetail(
      navigation,
      participant.id,
      participant.name,
      participant.avatar,
    );
  };

  const [confirm, setConfirm] = useState<{
    visible: boolean;
    title?: string;
    message?: string;
    onConfirm?: () => void;
    loading?: boolean;
  }>({ visible: false });

  const handleKick = (p: Participant) => {
    if (!tournament || user?.uid !== tournament.ownerId || p.role === "owner")
      return;
    const doKick = async () => {
      try {
        await TournamentService.kickParticipant(tournamentId, p.id);
      } catch (e) {
        const err = handleFirestoreError(e);
        setConfirm({
          visible: true,
          title: "エラー",
          message: err.message,
          onConfirm: () => setConfirm({ visible: false }),
        });
      }
    };
    setConfirm({
      visible: true,
      title: "参加者を削除",
      message: `「${p.name}」を参加者から削除します。よろしいですか？`,
      onConfirm: async () => {
        setConfirm((s) => ({ ...s, loading: true }));
        await doKick();
        setConfirm({ visible: false });
      },
    });
  };

  const renderParticipant = ({ item }: { item: Participant }) => {
    const { name, avatar } = useDisplayProfile(item.id, item.name, item.avatar);
    return (
      <TouchableOpacity
        style={styles.participantItem}
        onPress={() => handleParticipantPress(item)}
        activeOpacity={0.8}
      >
        {tournament && user?.uid === tournament.ownerId && item.role !== "owner" ? (
          <TouchableOpacity
            onPress={() => handleKick(item)}
            activeOpacity={0.8}
            style={styles.kickIconButton}
            accessibilityLabel="削除"
          >
            <Ionicons name="close" size={18} color={colors.white} />
          </TouchableOpacity>
        ) : (
          <View style={{ width: 0 }} />
        )}
        <UserProfileWithRank
          userName={name}
          userAvatar={avatar}
          averageDays={userAverageDays.get(item.id) || 0}
          size="small"
          showRank={false}
          showTitle={true}
          style={styles.userProfileContainer}
        />
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      {/* ヘッダー */}
      <View style={styles.header}>
        <TouchableOpacity onPress={handleBack} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>トーナメント</Text>
        <View style={styles.placeholder} />
      </View>

      {/* タブ */}
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tab, activeTab === "chat" && styles.activeTab]}
          onPress={() => setActiveTab("chat")}
        >
          <Text
            style={[
              styles.tabText,
              activeTab === "chat" && styles.activeTabText,
            ]}
          >
            チャット
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tab, activeTab === "participants" && styles.activeTab]}
          onPress={() => setActiveTab("participants")}
        >
          <Text
            style={[
              styles.tabText,
              activeTab === "participants" && styles.activeTabText,
            ]}
          >
            参加者
          </Text>
        </TouchableOpacity>
      </View>

      {/* コンテンツ */}
      {activeTab === "chat" ? (
        <KeyboardAwareScrollView style={styles.chatContainer}>
          <FlatList
            data={messages}
            renderItem={renderMessage}
            keyExtractor={(item) => item.id}
            style={styles.messagesList}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
            ref={listRef}
            inverted
            onEndReachedThreshold={0.2}
            onEndReached={() => {
              // inverted: end reached means top of history
              void loadOlder();
            }}
            onContentSizeChange={() => {
              if (!initialScrolled) {
                listRef.current?.scrollToEnd({ animated: false });
                setInitialScrolled(true);
              }
            }}
          />

          {(() => {
            const canSend = Boolean(
              user &&
                ((tournament && tournament.ownerId === user.uid) ||
                  participants.some(
                    (p) => p.id === user.uid && p.status === "joined",
                  )),
            );
            return canSend ? (
              <MessageInput onSend={handleSendMessage} />
            ) : (
              <View
                style={{
                  padding: spacing.lg,
                  backgroundColor: colors.white,
                  borderTopWidth: 1,
                  borderTopColor: colors.borderPrimary,
                }}
              >
                <Text style={{ color: colors.textSecondary }}>
                  参加者のみメッセージを送信できます
                </Text>
              </View>
            );
          })()}
        </KeyboardAwareScrollView>
      ) : (
        <View style={styles.participantsList}>
          {tournament &&
          user?.uid === tournament.ownerId &&
          joinRequests.length > 0 ? (
            <View style={styles.requestsSection}>
              <Text style={styles.requestsTitle}>参加申請</Text>
              {joinRequests.map((r) => (
                <View key={r.id} style={styles.requestRow}>
                  <UserProfileWithRank
                    userName={r.userName}
                    userAvatar={r.userAvatar}
                    averageDays={0}
                    size="small"
                    showRank={false}
                    showTitle={false}
                    style={styles.requestProfile}
                  />
                  <View style={styles.requestActions}>
                    <Button
                      title="承認"
                      size="small"
                      variant="primary"
                      onPress={() => {
                        void handleApprove(r.id);
                      }}
                    />
                    <Button
                      title="却下"
                      size="small"
                      variant="danger"
                      onPress={() => {
                        void handleReject(r.id);
                      }}
                    />
                  </View>
                </View>
              ))}
            </View>
          ) : null}
          <FlatList
            data={participants}
            renderItem={renderParticipant}
            keyExtractor={(item) => item.id}
            contentContainerStyle={styles.participantsContent}
            showsVerticalScrollIndicator={false}
          />
        </View>
      )}
      <ConfirmDialog
        visible={confirm.visible}
        title={confirm.title || ""}
        message={confirm.message}
        confirmText={confirm.title === "参加者を削除" ? "削除" : "OK"}
        cancelText={"キャンセル"}
        onConfirm={confirm.onConfirm || (() => setConfirm({ visible: false }))}
        onCancel={() => setConfirm({ visible: false })}
        loading={!!confirm.loading}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: {
    padding: spacing.sm,
  },
  headerTitle: {
    flex: 1,
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
    textAlign: "center",
  },
  placeholder: {
    width: 40,
  },
  headerAction: {
    padding: spacing.sm,
  },
  tabContainer: {
    flexDirection: "row",
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  tab: {
    flex: 1,
    paddingVertical: spacing.lg,
    alignItems: "center",
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
  },
  tabText: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textSecondary,
  },
  activeTabText: {
    color: colors.info,
  },
  chatContainer: {
    flex: 1,
  },
  messagesList: {
    flex: 1,
  },
  participantsList: {
    flex: 1,
  },
  participantsContent: {
    padding: spacing.lg,
  },
  requestsSection: {
    padding: spacing.lg,
    backgroundColor: colors.white,
    borderRadius: 12,
    marginHorizontal: spacing.lg,
    marginTop: spacing.lg,
    ...shadows.base,
  },
  requestsTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.gray800,
    marginBottom: spacing.md,
  },
  requestRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingVertical: spacing.sm,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  requestProfile: {
    flex: 1,
  },
  requestActions: {
    flexDirection: "row",
    gap: spacing.sm,
  },
  participantItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: colors.white,
    padding: spacing.lg,
    marginBottom: spacing.md,
    borderRadius: 12,
    ...shadows.base,
  },
  userProfileContainer: {
    marginLeft: spacing.md,
  },
  kickIconButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: colors.error,
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: {
    fontSize: typography.fontSize.base,
    fontWeight: "bold",
    color: colors.white,
  },
  participantInfo: {
    flex: 1,
  },
  participantHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  participantName: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.gray800,
  },
  progressText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
  },
});

export default TournamentRoomScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React, { useState, useEffect, useRef } from "react";
import {
  Alert,
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  FlatList,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import {
  TournamentService,
  handleFirestoreError,
} from "@core/services/firestore";
import UserService from "@core/services/userService";
import { UserStatsService } from "@core/services/userStatsService";
import MessageBubble from "@features/tournaments/components/MessageBubble";
import MessageInput from "@features/tournaments/components/MessageInput";
import Button from "@shared/components/Button";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import KeyboardAwareScrollView from "@shared/components/KeyboardAwareScrollView";
import UserProfileWithRank from "@shared/components/UserProfileWithRank";
import { useDisplayProfile } from "@shared/hooks/useDisplayProfile";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { toDate } from "@shared/utils/date";
import { navigateToUserDetail } from "@shared/utils/navigation";

type TournamentRoomScreenNavigationProp = StackNavigationProp<
  TournamentStackParamList,
  "TournamentRoom"
>;

interface Message {
  id: string;
  authorId: string;
  authorName: string;
  text: string;
  timestamp: Date;
  type: "text" | "system";
  avatar?: string;
}

interface Participant {
  id: string;
  name: string;
  avatar?: string;
  role: "owner" | "member";
  status: "joined" | "left" | "kicked" | "completed" | "failed";
  progressPercent?: number;
  currentDay?: number;
}

interface JoinRequest {
  id: string;
  userId: string;
  userName: string;
  userAvatar?: string;
}

interface TournamentRoomScreenProps {
  route: {
    params: {
      tournamentId: string;
    };
  };
}

const TournamentRoomScreen: React.FC<TournamentRoomScreenProps> = ({
  route,
}) => {
  const navigation = useNavigation<TournamentRoomScreenNavigationProp>();
  const { tournamentId } = route.params;
  const [activeTab, setActiveTab] = useState<"chat" | "participants">("chat");
  const { user } = useAuth();

  // チャットメッセージ
  const [messages, setMessages] = useState<Message[]>([]);
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [tournament, setTournament] = useState<{ ownerId?: string } | null>(
    null,
  );
  const [joinRequests, setJoinRequests] = useState<JoinRequest[]>([]);
  // const [loading, setLoading] = useState(true);
  const [userAverageDays, setUserAverageDays] = useState<Map<string, number>>(
    new Map(),
  );

  // スクロール制御
  const listRef = useRef<FlatList<Message>>(null);
  const [initialScrolled, setInitialScrolled] = useState(false);
  // チャットは常に最新が最下部になるよう inverted を使用

  // 初期100件 + 新着の随時取得
  useEffect(() => {
    let unsubNew: undefined | (() => void);
    let cancelled = false;
    (async () => {
      try {
        // 最新から100件取得（desc）→ asc に並べ替えて状態に保存
        const { items, nextCursor } = await TournamentService.getRecentMessages(
          tournamentId,
          100,
        );
        const latestDesc = items; // already desc (newest first)
        if (cancelled) return;
        setMessages(
          latestDesc.map((msg) => ({
            id: msg.id,
            authorId: msg.authorId,
            authorName: msg.authorName,
            text: msg.text,
            timestamp: toDate(msg.createdAt),
            type: msg.type,
            avatar: msg.authorAvatar,
          })),
        );
        // 新着を購読（最新のcreatedAt以降）
        const latestTs = latestDesc[0]?.createdAt as any;
        if (latestTs) {
          unsubNew = TournamentService.subscribeToNewMessages(
            tournamentId,
            latestTs,
            (news) => {
              if (!news || news.length === 0) return;
              setMessages((prev) => {
                const existing = new Set(prev.map((p) => p.id));
                // news is asc; convert to desc and put at start
                const appended = [...news]
                  .reverse()
                  .map((msg) => ({
                    id: msg.id,
                    authorId: msg.authorId,
                    authorName: msg.authorName,
                    text: msg.text,
                    timestamp: toDate(msg.createdAt),
                    type: msg.type,
                    avatar: msg.authorAvatar,
                  }))
                  .filter((m) => !existing.has(m.id));
                if (appended.length === 0) return prev;
                return [...appended, ...prev];
              });
            },
          );
        }
        // keep cursor for older loads
        setOlderCursor(nextCursor);
      } catch (e) {
        console.warn("failed to init chat messages:", e);
      }
    })();
    return () => {
      cancelled = true;
      if (unsubNew) unsubNew();
    };
  }, [tournamentId]);

  const [olderCursor, setOlderCursor] = useState<any | undefined>(undefined);
  const [loadingMore, setLoadingMore] = useState(false);
  const loadOlder = async () => {
    if (loadingMore || !olderCursor) return;
    setLoadingMore(true);
    try {
      const { items, nextCursor } = await TournamentService.getRecentMessages(
        tournamentId,
        50,
        olderCursor,
      );
      // items are older (desc). Keep desc and append to tail
      const olderDesc = items.map((msg) => ({
        id: msg.id,
        authorId: msg.authorId,
        authorName: msg.authorName,
        text: msg.text,
        timestamp: toDate(msg.createdAt),
        type: msg.type,
        avatar: msg.authorAvatar,
      }));
      setMessages((prev) => [...prev, ...olderDesc]);
      setOlderCursor(nextCursor);
    } finally {
      setLoadingMore(false);
    }
  };

  // 大会情報と参加者の購読
  useEffect(() => {
    let unsubscribeParticipants: undefined | (() => void);
    let unsubscribeRequests: undefined | (() => void);
    const init = async () => {
      try {
        const tournamentData =
          await TournamentService.getTournament(tournamentId);
        setTournament(tournamentData);
        // オーナー情報を取得。Firestore優先、なければローカルにフォールバック
        let ownerDisplayName: string | undefined;
        let ownerAvatarUrl: string | undefined;
        try {
          if (tournamentData?.ownerId) {
            const owner = await (
              await import("@core/services/firestore")
            ).FirestoreUserService.getUserById(tournamentData.ownerId);
            ownerDisplayName = owner?.displayName;
            ownerAvatarUrl = owner?.photoURL ?? undefined;
          }
        } catch {
          // noop
        }
        if (!ownerDisplayName) {
          const userService = UserService.getInstance();
          ownerDisplayName =
            tournamentData?.ownerId === user?.uid
              ? user?.displayName || undefined
              : await userService.getUserName();
        }
        if (!ownerAvatarUrl) {
          const userService = UserService.getInstance();
          ownerAvatarUrl =
            tournamentData?.ownerId === user?.uid
              ? user?.avatarUrl || undefined
              : await userService.getAvatarUrl();
        }

        unsubscribeParticipants = TournamentService.subscribeToParticipants(
          tournamentId,
          async (list) => {
            // オーナーが含まれていなければ追加
            const ownerExists = list.some(
              (p) => p.userId === tournamentData?.ownerId,
            );
            const all =
              ownerExists || !tournamentData?.ownerId
                ? list
                : [
                    {
                      id: "owner-participant",
                      tournamentId,
                      userId: tournamentData.ownerId,
                      userName: ownerDisplayName || "ユーザー",
                      userAvatar: ownerAvatarUrl,
                      status: "joined",
                      joinedAt: tournamentData.createdAt,
                      progressPercent: 0,
                      currentDay: 0,
                    },
                    ...list,
                  ];

            const converted: Participant[] = all.map((p) => ({
              id: p.userId,
              name: p.userName,
              avatar: p.userAvatar,
              role: p.userId === tournamentData?.ownerId ? "owner" : "member",
              status: p.status as Participant["status"],
              progressPercent: p.progressPercent,
              currentDay: p.currentDay,
            }));

            setParticipants(converted);

            // 参加者ごとの平均日数を取得
            const averageDaysMap = new Map<string, number>();
            for (const participant of converted) {
              try {
                const days = await UserStatsService.getUserCurrentDaysForRank(
                  participant.id,
                );
                averageDaysMap.set(participant.id, days);
              } catch (error) {
                console.error(
                  "ユーザーの平均日数取得に失敗",
                  participant.id,
                  error,
                );
                averageDaysMap.set(participant.id, 0);
              }
            }
            setUserAverageDays(averageDaysMap);
          },
        );

        // 参加申請の購読（オーナーのみ表示用）
        unsubscribeRequests = TournamentService.subscribeToJoinRequests(
          tournamentId,
          (reqs) => {
            const pending = reqs.filter((r) => r.status === "pending");
            const mapped: JoinRequest[] = pending.map((r) => ({
              id: r.id,
              userId: r.userId,
              userName: r.userName,
              userAvatar: r.userAvatar ?? undefined,
            }));
            setJoinRequests(mapped);
          },
        );
      } catch (e) {
        console.error("トーナメントの参加者取得でエラーが発生しました:", e);
        Alert.alert("エラー", "トーナメントの参加者取得でエラーが発生しました");
      }
    };
    void init();
    return () => {
      if (unsubscribeParticipants) unsubscribeParticipants();
      if (unsubscribeRequests) unsubscribeRequests();
    };
  }, [tournamentId]);

  const handleApprove = async (requestId: string) => {
    try {
      await TournamentService.approveJoinRequest(requestId);
    } catch (e) {
      const err = handleFirestoreError(e);
      setConfirm({
        visible: true,
        title: "エラー",
        message: err.message,
        onConfirm: () => setConfirm({ visible: false }),
      });
    }
  };

  const handleReject = async (requestId: string) => {
    try {
      await TournamentService.rejectJoinRequest(requestId);
    } catch (e) {
      const err = handleFirestoreError(e);
      setConfirm({
        visible: true,
        title: "エラー",
        message: err.message,
        onConfirm: () => setConfirm({ visible: false }),
      });
    }
  };

  const handleSendMessage = async (text: string) => {
    if (!text.trim()) return;

    // 楽観的にメッセージを1件だけ即時追加（他のUIは触らない）
    const localId = `local-${Date.now()}`;
    const optimistic: Message = {
      id: localId,
      authorId: user?.uid || "me",
      authorName: user?.displayName || "あなた",
      text: text.trim(),
      timestamp: new Date(),
      type: "text",
      avatar: user?.avatarUrl || undefined,
    };
    // desc: newest first → 先頭に追加
    setMessages((prev) => [optimistic, ...prev]);

    try {
      // メッセージポートエラー対策のため、タイムアウトを設定
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(
          () => reject(new Error("メッセージ送信がタイムアウトしました")),
          10000,
        );
      });

      const sendPromise = TournamentService.sendMessage(
        tournamentId,
        text.trim(),
      );

      const newId = (await Promise.race([
        sendPromise,
        timeoutPromise,
      ])) as string;
      // サーバIDに置き換え。既に同IDのサーバメッセージが来ていれば重複除去
      setMessages((prev) => {
        const mapped = prev.map((m) =>
          m.id === localId ? { ...m, id: newId } : m,
        );
        const seen = new Set<string>();
        const dedup: Message[] = [];
        for (const m of mapped) {
          if (seen.has(m.id)) continue;
          seen.add(m.id);
          dedup.push(m);
        }
        return dedup;
      });
    } catch (error) {
      // 失敗時は楽観的メッセージを除去
      setMessages((prev) => prev.filter((m) => m.id !== localId));
      console.error("メッセージの送信でエラーが発生しました:", error);

      // メッセージポートエラーの場合の特別な処理
      if (error instanceof Error && error.message.includes("message port")) {
        console.warn(
          "メッセージポートエラーが発生しましたが、メッセージは送信された可能性があります",
        );
        return; // エラーを表示せずに処理を継続
      }

      const firestoreError = handleFirestoreError(error);
      Alert.alert("エラー", firestoreError.message);
    }
  };

  const handleBack = () => {
    navigation.goBack();
  };

  const renderMessage = ({ item }: { item: Message }) => {
    const isOwn = user ? item.authorId === user.uid : false;

    return (
      <MessageBubble
        message={item}
        isOwn={isOwn}
        onUserPress={(uid, uname, uavatar) =>
          navigateToUserDetail(navigation, uid, uname, uavatar)
        }
      />
    );
  };

  const handleParticipantPress = (participant: Participant) => {
    navigateToUserDetail(
      navigation,
      participant.id,
      participant.name,
      participant.avatar,
    );
  };

  const [confirm, setConfirm] = useState<{
    visible: boolean;
    title?: string;
    message?: string;
    onConfirm?: () => void;
    loading?: boolean;
  }>({ visible: false });

  const handleKick = (p: Participant) => {
    if (!tournament || user?.uid !== tournament.ownerId || p.role === "owner")
      return;
    const doKick = async () => {
      try {
        await TournamentService.kickParticipant(tournamentId, p.id);
      } catch (e) {
        const err = handleFirestoreError(e);
        setConfirm({
          visible: true,
          title: "エラー",
          message: err.message,
          onConfirm: () => setConfirm({ visible: false }),
        });
      }
    };
    setConfirm({
      visible: true,
      title: "参加者を削除",
      message: `「${p.name}」を参加者から削除します。よろしいですか？`,
      onConfirm: async () => {
        setConfirm((s) => ({ ...s, loading: true }));
        await doKick();
        setConfirm({ visible: false });
      },
    });
  };

  const renderParticipant = ({ item }: { item: Participant }) => {
    const { name, avatar } = useDisplayProfile(item.id, item.name, item.avatar);
    return (
      <TouchableOpacity
        style={styles.participantItem}
        onPress={() => handleParticipantPress(item)}
        activeOpacity={0.8}
      >
        {tournament && user?.uid === tournament.ownerId && item.role !== "owner" ? (
          <TouchableOpacity
            onPress={() => handleKick(item)}
            activeOpacity={0.8}
            style={styles.kickIconButton}
            accessibilityLabel="削除"
          >
            <Ionicons name="close" size={18} color={colors.white} />
          </TouchableOpacity>
        ) : (
          <View style={{ width: 0 }} />
        )}
        <UserProfileWithRank
          userName={name}
          userAvatar={avatar}
          averageDays={userAverageDays.get(item.id) || 0}
          size="small"
          showRank={false}
          showTitle={true}
          style={styles.userProfileContainer}
        />
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      {/* ヘッダー */}
      <View style={styles.header}>
        <TouchableOpacity onPress={handleBack} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>トーナメント</Text>
        <View style={styles.placeholder} />
      </View>

      {/* タブ */}
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tab, activeTab === "chat" && styles.activeTab]}
          onPress={() => setActiveTab("chat")}
        >
          <Text
            style={[
              styles.tabText,
              activeTab === "chat" && styles.activeTabText,
            ]}
          >
            チャット
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tab, activeTab === "participants" && styles.activeTab]}
          onPress={() => setActiveTab("participants")}
        >
          <Text
            style={[
              styles.tabText,
              activeTab === "participants" && styles.activeTabText,
            ]}
          >
            参加者
          </Text>
        </TouchableOpacity>
      </View>

      {/* コンテンツ */}
      {activeTab === "chat" ? (
        <KeyboardAwareScrollView style={styles.chatContainer}>
          <FlatList
            data={messages}
            renderItem={renderMessage}
            keyExtractor={(item) => item.id}
            style={styles.messagesList}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
            ref={listRef}
            inverted
            onEndReachedThreshold={0.2}
            onEndReached={() => {
              // inverted: end reached means top of history
              void loadOlder();
            }}
            onContentSizeChange={() => {
              if (!initialScrolled) {
                listRef.current?.scrollToEnd({ animated: false });
                setInitialScrolled(true);
              }
            }}
          />

          {(() => {
            const canSend = Boolean(
              user &&
                ((tournament && tournament.ownerId === user.uid) ||
                  participants.some(
                    (p) => p.id === user.uid && p.status === "joined",
                  )),
            );
            return canSend ? (
              <MessageInput onSend={handleSendMessage} />
            ) : (
              <View
                style={{
                  padding: spacing.lg,
                  backgroundColor: colors.white,
                  borderTopWidth: 1,
                  borderTopColor: colors.borderPrimary,
                }}
              >
                <Text style={{ color: colors.textSecondary }}>
                  参加者のみメッセージを送信できます
                </Text>
              </View>
            );
          })()}
        </KeyboardAwareScrollView>
      ) : (
        <View style={styles.participantsList}>
          {tournament &&
          user?.uid === tournament.ownerId &&
          joinRequests.length > 0 ? (
            <View style={styles.requestsSection}>
              <Text style={styles.requestsTitle}>参加申請</Text>
              {joinRequests.map((r) => (
                <View key={r.id} style={styles.requestRow}>
                  <UserProfileWithRank
                    userName={r.userName}
                    userAvatar={r.userAvatar}
                    averageDays={0}
                    size="small"
                    showRank={false}
                    showTitle={false}
                    style={styles.requestProfile}
                  />
                  <View style={styles.requestActions}>
                    <Button
                      title="承認"
                      size="small"
                      variant="primary"
                      onPress={() => {
                        void handleApprove(r.id);
                      }}
                    />
                    <Button
                      title="却下"
                      size="small"
                      variant="danger"
                      onPress={() => {
                        void handleReject(r.id);
                      }}
                    />
                  </View>
                </View>
              ))}
            </View>
          ) : null}
          <FlatList
            data={participants}
            renderItem={renderParticipant}
            keyExtractor={(item) => item.id}
            contentContainerStyle={styles.participantsContent}
            showsVerticalScrollIndicator={false}
          />
        </View>
      )}
      <ConfirmDialog
        visible={confirm.visible}
        title={confirm.title || ""}
        message={confirm.message}
        confirmText={confirm.title === "参加者を削除" ? "削除" : "OK"}
        cancelText={"キャンセル"}
        onConfirm={confirm.onConfirm || (() => setConfirm({ visible: false }))}
        onCancel={() => setConfirm({ visible: false })}
        loading={!!confirm.loading}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: {
    padding: spacing.sm,
  },
  headerTitle: {
    flex: 1,
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
    textAlign: "center",
  },
  placeholder: {
    width: 40,
  },
  headerAction: {
    padding: spacing.sm,
  },
  tabContainer: {
    flexDirection: "row",
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  tab: {
    flex: 1,
    paddingVertical: spacing.lg,
    alignItems: "center",
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
  },
  tabText: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.textSecondary,
  },
  activeTabText: {
    color: colors.info,
  },
  chatContainer: {
    flex: 1,
  },
  messagesList: {
    flex: 1,
  },
  participantsList: {
    flex: 1,
  },
  participantsContent: {
    padding: spacing.lg,
  },
  requestsSection: {
    padding: spacing.lg,
    backgroundColor: colors.white,
    borderRadius: 12,
    marginHorizontal: spacing.lg,
    marginTop: spacing.lg,
    ...shadows.base,
  },
  requestsTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.gray800,
    marginBottom: spacing.md,
  },
  requestRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingVertical: spacing.sm,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  requestProfile: {
    flex: 1,
  },
  requestActions: {
    flexDirection: "row",
    gap: spacing.sm,
  },
  participantItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: colors.white,
    padding: spacing.lg,
    marginBottom: spacing.md,
    borderRadius: 12,
    ...shadows.base,
  },
  userProfileContainer: {
    marginLeft: spacing.md,
  },
  kickIconButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: colors.error,
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: {
    fontSize: typography.fontSize.base,
    fontWeight: "bold",
    color: colors.white,
  },
  participantInfo: {
    flex: 1,
  },
  participantHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  participantName: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.gray800,
  },
  progressText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
  },
});

export default TournamentRoomScreen;

*** Update File: src/features/profile/screens/UserDetailScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import type { RouteProp } from "@react-navigation/native";
import {
  useRoute,
  useNavigation,
  useFocusEffect,
} from "@react-navigation/native";
import React, { useEffect, useState, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import {
  CommunityService,
  FollowService,
  BlockService,
} from "@core/services/firestore";
import type { FirestoreCommunityPost } from "@core/services/firestore";
import { UserStatsService } from "@core/services/userStatsService";
import PostList from "@features/community/components/PostList";
import ReplyInputBar from "@shared/components/ReplyInputBar";
import AvatarImage from "@shared/components/AvatarImage";
import { getRankDisplayByDays } from "@core/services/rankService";
import { useDisplayProfile } from "@shared/hooks/useDisplayProfile";
import { BlockStore } from "@shared/state/blockStore";
import { FollowStore } from "@shared/state/followStore";
import { colors, spacing, typography } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import {
  buildReplyCountMapFromPosts,
  normalizeCommunityPostsFirestore,
  incrementCountMap,
} from "@shared/utils/community";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";

type RootStackParamList = {
  UserDetail: { userId: string; userName?: string; userAvatar?: string };
};

type UserDetailRouteProp = RouteProp<RootStackParamList, "UserDetail">;

const UserDetailScreen: React.FC = () => {
  const route = useRoute<UserDetailRouteProp>();
  const navigation = useNavigation();
  const { userId, userName, userAvatar } = route.params || ({} as any);
  const { user } = useAuth();
  const { name: liveName, avatar: liveAvatar } = useDisplayProfile(
    userId,
    userName,
    userAvatar,
  );
  const [name, setName] = useState<string>(liveName || "ユーザー");
  const [avatar, setAvatar] = useState<string | undefined>(liveAvatar);
  const [following, setFollowing] = useState<boolean>(false);
  const [postsData, setPostsData] = useState<FirestoreCommunityPost[]>([]);
  const [loadingMore, setLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [blocked, setBlocked] = useState<boolean>(false);
  const [likedPosts, setLikedPosts] = useState<Set<string>>(new Set());
  const [showReplyButtons, setShowReplyButtons] = useState<Set<string>>(
    new Set(),
  );
  const [replyingTo, setReplyingTo] = useState<string | null>(null);
  const [replyText, setReplyText] = useState("");
  const [replyCounts, setReplyCounts] = useState<Map<string, number>>(
    new Map(),
  );
  const [averageDays, setAverageDays] = useState(0);
  const [likingIds, setLikingIds] = useState<Set<string>>(new Set());
  const [followersCount, setFollowersCount] = useState(0);
  const [followingCount, setFollowingCount] = useState(0);
  const { requireAuth } = useAuthPrompt();
  // 相対時間表示は各セル内の RelativeTime コンポーネントで個別に更新
  // 相対時間更新は各セル側で行うため、画面全体の毎秒再レンダは不要

  // Recompute rank on focus to keep consistency with post lists
  useFocusEffect(
    useCallback(() => {
      let mounted = true;
      (async () => {
        try {
          const days = await UserStatsService.getUserCurrentDaysForRank(userId);
          if (mounted) setAverageDays(days);
        } catch { }
        try {
          const c = await FollowService.getCounts(userId);
          if (mounted) {
            setFollowingCount(c.following);
            setFollowersCount(c.followers);
          }
        } catch { }
      })();
      return () => {
        mounted = false;
      };
    }, [userId]),
  );

  useEffect(() => {
    setName(liveName || "ユーザー");
    setAvatar(liveAvatar);
    if (!userId) return;
    (async () => {
      const days = await UserStatsService.getUserCurrentDaysForRank(userId).catch(() => 0);
      setAverageDays(days);
    })();
  }, [userId, liveName, liveAvatar]);

  // Fallback: if profile avatar is missing, borrow latest from posts snapshot
  useEffect(() => {
    if (!avatar) {
      const a = postsData.find((p) => p.authorAvatar)?.authorAvatar;
      if (a) setAvatar(a);
    }
  }, [postsData, avatar]);

  // Initialize LikeStore from server state once; do not override user taps
  useEffect(() => {
    let timer: any | undefined;
    (async () => {
      try {
        const { LikeStore } = await import("@shared/state/likeStore");
        // 16ms 以内に来た更新をまとめて反映
        const apply = () => {
          postsData.forEach((p) => {
            LikeStore.setFromServer(p.id, {
              isLiked: likedPosts.has(p.id),
              likes: p.likes || 0,
            });
          });
          timer = undefined;
        };
        if (!timer) timer = setTimeout(apply, 16);
      } catch { }
    })();
    return () => { if (timer) clearTimeout(timer); };
  }, [likedPosts, postsData]);
  useEffect(() => {
    let unsubscribe: (() => void) | undefined;
    let mounted = true;

    (async () => {
      try {
        const isFollowing = await FollowService.isFollowing(userId);
        if (mounted) setFollowing(isFollowing);
      } catch { }

      try {
        const isBlocked = await BlockService.isBlocked(userId);
        if (mounted) setBlocked(isBlocked);
      } catch { }

      try {
        const c = await FollowService.getCounts(userId);
        if (mounted) {
          setFollowingCount(c.following);
          setFollowersCount(c.followers);
        }
      } catch { }

      try {
        unsubscribe = CommunityService.subscribeToUserPosts(
          userId,
          async (list) => {
            const normalized = normalizeCommunityPostsFirestore(list);

            // 返信の取得はトークアイコン押下時に行うため、
            // ここでは Firestore から返信一覧を取得しない。
            // 表示用の件数は投稿の `comments` を利用する。
            const counts = buildReplyCountMapFromPosts(normalized);

            setReplyCounts(counts);
            setPostsData(normalized);

            if (user) {
              try {
                const ids = normalized.map((p) => p.id);
                const set = await CommunityService.getLikedPostIds(user.uid, ids);
                setLikedPosts(set);
              } catch { }
            }
          },
        );
      } catch { }
    })();

    return () => {
      mounted = false;
      if (unsubscribe) unsubscribe();
    };
  }, [userId, user]);

  const handlePostPress = (post: FirestoreCommunityPost) => {
    navigateToUserDetail(
      navigation,
      post.authorId,
      post.authorName,
      post.authorAvatar,
    );
  };

  const handleLike = async (postId: string) => {
    const ok = await requireAuth();
    if (!ok) return;
    if (likingIds.has(postId)) return;
    setLikingIds((prev) => new Set(prev).add(postId));
    try {
      await CommunityService.toggleLike(postId);
    } catch (e) {
      console.warn("like toggle failed", e);
    } finally {
      setLikingIds((prev) => {
        const s = new Set(prev);
        s.delete(postId);
        return s;
      });
    }
  };

  const handleComment = (postId: string) => {
    try {
      const {
        ReplyVisibilityStore,
      } = require("@shared/state/replyVisibilityStore");
      ReplyVisibilityStore.toggle(postId);
    } catch { }
  };

  const handleReply = async (postId: string) => {
    const ok = await requireAuth();
    if (!ok) return;
    setReplyingTo(postId);
    setReplyText("");
  };

  const handleReplySubmit = async () => {
    if (!replyingTo || !replyText.trim()) return;
    const ok = await requireAuth();
    if (!ok) return;
    try {
      await CommunityService.addReply(replyingTo, {
        content: replyText.trim(),
      });
      setReplyCounts((prev) => incrementCountMap(prev, replyingTo, 1));
      // Update minimal UI: just the bubble count for this post
      try {
        const { ReplyCountStore } = await import("@shared/state/replyStore");
        ReplyCountStore.increment(replyingTo, 1);
      } catch { }
      setReplyingTo(null);
      setReplyText("");
    } catch (e) {
      console.warn("reply failed", e);
    }
  };

  const handleReplyCancel = () => {
    setReplyingTo(null);
    setReplyText("");
  };

  // PostList が各種描画を担当

  const onToggleFollow = async () => {
    try {
      const ok = await requireAuth();
      if (!ok) return;
      if (following) {
        // Optimistic update
        FollowStore.remove(userId);
        await FollowService.unfollow(userId);
        setFollowing(false);
        setFollowersCount((n) => Math.max(0, n - 1));
      } else {
        // Optimistic update
        FollowStore.add(userId);
        await FollowService.follow(userId);
        setFollowing(true);
        setFollowersCount((n) => n + 1);
      }
    } catch (e) {
      console.warn("follow toggle failed", e);
    }
  };

  const onToggleBlock = async () => {
    try {
      const ok = await requireAuth();
      if (!ok) return;
      const wasFollowing = following;
      if (blocked) {
        // Optimistic
        BlockStore.remove(userId);
        await BlockService.unblock(userId);
        setBlocked(false);
      } else {
        // Optimistic
        BlockStore.add(userId);
        await BlockService.block(userId);
        setBlocked(true);
        // Also reflect follow state locally; block will unfollow on server
        setFollowing(false);
        try {
          FollowStore.remove(userId);
        } catch { }
        if (wasFollowing) {
          setFollowersCount((n) => Math.max(0, n - 1));
        }
      }
    } catch (e) {
      console.warn("block toggle failed", e);
    }
  };

  // 相対時間は共通関数を使用

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor={colors.white} />

      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>プロフィール</Text>
        <View style={{ width: 32 }} />
      </View>

      {/* プロフィールヘッダーは PostList の ListHeaderComponent に移動し、スクロールに追従させる */}

      {/* 投稿一覧 */}
      <PostList
        posts={postsData}
        likedPosts={likedPosts}
        showReplyButtons={showReplyButtons}
        hasMore={false}
        replyCounts={replyCounts}
        authorAverageDays={averageDays}
        allowBlockedReplies={true}
        headerComponent={(
          <View>
            <View style={styles.profileHeaderCenter}>
              <AvatarImage
                uri={avatar}
                size={88}
                style={styles.profileAvatar}
              />
              <Text style={styles.profileName} numberOfLines={1}>
                {name}
              </Text>
              <Text style={styles.profileRank} numberOfLines={1}>
                {getRankDisplayByDays(averageDays)}
              </Text>
            </View>

            {user?.uid !== userId && (
              <View style={styles.ctaRow}>
                <TouchableOpacity
                  activeOpacity={0.8}
                  onPress={onToggleFollow}
                  style={[styles.primaryCta, following && styles.primaryCtaActive]}
                >
                  <Ionicons
                    name={following ? "checkmark" : "person-add-outline"}
                    size={18}
                    color={colors.black}
                    style={styles.ctaIcon}
                  />
                  <Text style={styles.primaryCtaText}>
                    {following ? "フォロー中" : "フォロー"}
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  activeOpacity={0.8}
                  onPress={onToggleBlock}
                  style={[styles.ghostCta, blocked && styles.ghostCtaActive]}
                >
                  <Ionicons
                    name={blocked ? "close-circle" : "remove-circle-outline"}
                    size={18}
                    color={blocked ? colors.gray800 : colors.textSecondary}
                    style={styles.ctaIcon}
                  />
                  <Text
                    style={[
                      styles.ghostCtaText,
                      blocked && styles.ghostCtaTextActive,
                    ]}
                  >
                    {blocked ? "ブロック中" : "ブロック"}
                  </Text>
                </TouchableOpacity>
              </View>
            )}

            {/* 投稿/フォロー/フォロワー カウント（余計な隙間を作らないため Divider は置かない） */}
            <View style={styles.statsRow}>
              <View style={styles.statItem}>
                <Text style={styles.statNumber}>{postsData.length}</Text>
                <Text style={styles.statLabel}>投稿</Text>
              </View>
              <View style={styles.statDivider} />
              <TouchableOpacity
                style={styles.statItem}
                activeOpacity={0.8}
                onPress={() =>
                  (navigation as any).navigate("FollowList", {
                    userId,
                    userName: name,
                    mode: "following",
                  })
                }
              >
                <Text style={styles.statNumber}>{followingCount}</Text>
                <Text style={styles.statLabel}>フォロー</Text>
              </TouchableOpacity>
              <View style={styles.statDivider} />
              <TouchableOpacity
                style={styles.statItem}
                activeOpacity={0.8}
                onPress={() =>
                  (navigation as any).navigate("FollowList", {
                    userId,
                    userName: name,
                    mode: "followers",
                  })
                }
              >
                <Text style={styles.statNumber}>{followersCount}</Text>
                <Text style={styles.statLabel}>フォロワー</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
        onLike={(id) => {
          void handleLike(id);
        }}
        onComment={handleComment}
        onReply={handleReply}
        onUserPress={(uid, uname) =>
          handlePostPress({ authorId: uid, authorName: uname } as any)
        }
        listStyle={{ flex: 1 }}
        contentContainerStyle={uiStyles.listContainer}
        onEndReached={() => {
          if (!hasMore || loadingMore || postsData.length === 0) return;
          // TODO: ページング対応を実装
        }}
        loadingMore={loadingMore}
      />

      {/* 返信入力フィールド */}
      {replyingTo && (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "padding"}
          keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 16}
        >
          <ReplyInputBar
            value={replyText}
            onChangeText={setReplyText}
            onCancel={handleReplyCancel}
            onSubmit={handleReplySubmit}
            autoFocus
          />
        </KeyboardAvoidingView>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: { padding: spacing.sm },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  listContainer: {
    backgroundColor: colors.white,
  },
  empty: {
    paddingVertical: spacing["3xl"],
    alignItems: "center",
  },
  emptyText: {
    color: colors.textSecondary,
  },
  // 新しいプロフィールヘッダー（縦並び: アイコン → 名前 → 階級）
  profileHeaderCenter: {
    alignItems: "center",
    paddingHorizontal: spacing.xl,
    paddingTop: spacing["2xl"],
    paddingBottom: spacing.lg,
    backgroundColor: colors.white,
  },
  profileAvatar: {
    marginBottom: spacing.md,
  },
  profileName: {
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  profileRank: {
    marginTop: 4,
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
    fontWeight: "500",
  },
  // CTA 行（左: フォロー[黄塗り] 右: ブロック[枠線のみ]）
  ctaRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: spacing.md,
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing.md,
    backgroundColor: colors.white,
  },
  primaryCta: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#FACC15", // amber-400 に近い黄
    borderRadius: 28,
    paddingVertical: 10,
  },
  primaryCtaActive: {
    backgroundColor: "#FDE047", // amber-300 っぽい薄黄（フォロー中）
  },
  primaryCtaText: {
    color: colors.black,
    fontSize: typography.fontSize.base,
    fontWeight: "700",
  },
  ghostCta: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: colors.white,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 28,
    paddingVertical: 10,
  },
  ghostCtaActive: {
    backgroundColor: "#E5E7EB",
    borderColor: "#CBD5E1",
  },
  ghostCtaText: {
    color: colors.textSecondary,
    fontSize: typography.fontSize.base,
    fontWeight: "700",
  },
  ghostCtaTextActive: {
    color: colors.gray800,
  },
  ctaIcon: {
    marginRight: 8,
  },
  // 旧スタイル（参照用）
  actionsRow: { flexDirection: "row", alignItems: "center", gap: spacing.sm },
  userProfileContainer: {
    flex: 1,
    marginRight: spacing.sm,
  },
  followBtn: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: spacing.md,
    paddingVertical: 4,
    minHeight: 28,
    borderColor: "#F87171",
    backgroundColor: colors.white,
  },
  followText: {
    color: "#F87171",
    fontSize: typography.fontSize.xs,
    fontWeight: "600",
  },
  follow: {
    backgroundColor: colors.white,
  },
  following: {
    backgroundColor: "#FDE2E2",
  },
  followingText: {
    color: "#EF4444",
    fontWeight: "700",
  },
  blockBtn: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: spacing.md,
    paddingVertical: 4,
    minHeight: 28,
  },
  blockText: {
    color: colors.textSecondary,
    fontSize: typography.fontSize.xs,
    fontWeight: "600",
  },
  block: {
    backgroundColor: colors.white,
    borderColor: colors.borderPrimary,
  },
  blocking: {
    backgroundColor: "#E5E7EB",
    borderColor: "#9CA3AF",
  },
  blockingText: {
    color: colors.gray800,
    fontWeight: "700",
  },
  divider: {
    height: 8,
    backgroundColor: colors.backgroundTertiary,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: colors.borderPrimary,
  },
  postItem: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  postHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  postAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: spacing.md,
  },
  postAvatarPlaceholder: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.gray100,
    alignItems: "center",
    justifyContent: "center",
    marginRight: spacing.md,
  },
  postAvatarInitial: { fontWeight: "700", color: colors.textSecondary },
  postAuthor: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.gray800,
  },
  postDot: { marginHorizontal: 6, color: colors.textSecondary },
  postTime: { fontSize: typography.fontSize.sm, color: colors.textSecondary },
  postContent: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    lineHeight: 22,
    marginBottom: spacing.sm,
    marginLeft: 56,
  }, // アバター40px + マージン16px = 56px
  postActions: { flexDirection: "row", alignItems: "center", marginLeft: 56 }, // アバター40px + マージン16px = 56px
  postAction: {
    flexDirection: "row",
    alignItems: "center",
    marginRight: spacing["3xl"],
  },
  postActionText: { marginLeft: 6, color: colors.textSecondary },
  replyInputContainer: {
    backgroundColor: colors.gray50,
    padding: spacing.lg,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  replyInput: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.md,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    minHeight: 80,
    textAlignVertical: "top",
    marginBottom: spacing.md,
  },
  replyInputActions: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    gap: spacing.md,
  },
  replyCancelButton: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
  },
  replyCancelText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium as any,
  },
  replySubmitButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
    minWidth: 60,
    alignItems: "center",
  },
  replySubmitButtonDisabled: { backgroundColor: colors.gray300 },
  replySubmitText: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    fontWeight: typography.fontWeight.semibold as any,
  },
  replySubmitTextDisabled: { color: colors.gray500 },
  // stats
  statsRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    backgroundColor: colors.white,
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.xl,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: colors.borderPrimary,
  },
  statItem: {
    flex: 1,
    alignItems: "center",
  },
  statNumber: {
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  statLabel: {
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
    marginTop: 2,
  },
  statDivider: {
    width: 1,
    alignSelf: "stretch",
    backgroundColor: colors.borderPrimary,
    marginHorizontal: spacing.lg,
    opacity: 0.6,
  },
});

export default UserDetailScreen;

+import { Ionicons } from "@expo/vector-icons";
import type { RouteProp } from "@react-navigation/native";
import {
  useRoute,
  useNavigation,
  useFocusEffect,
} from "@react-navigation/native";
import React, { useEffect, useState, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import {
  CommunityService,
  FollowService,
  BlockService,
} from "@core/services/firestore";
import type { FirestoreCommunityPost } from "@core/services/firestore";
import { UserStatsService } from "@core/services/userStatsService";
import PostList from "@features/community/components/PostList";
import ReplyInputBar from "@shared/components/ReplyInputBar";
import AvatarImage from "@shared/components/AvatarImage";
import { getRankDisplayByDays } from "@core/services/rankService";
import { useDisplayProfile } from "@shared/hooks/useDisplayProfile";
import { BlockStore } from "@shared/state/blockStore";
import { FollowStore } from "@shared/state/followStore";
import { colors, spacing, typography } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import {
  buildReplyCountMapFromPosts,
  normalizeCommunityPostsFirestore,
  incrementCountMap,
} from "@shared/utils/community";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";

type RootStackParamList = {
  UserDetail: { userId: string; userName?: string; userAvatar?: string };
};

type UserDetailRouteProp = RouteProp<RootStackParamList, "UserDetail">;

const UserDetailScreen: React.FC = () => {
  const route = useRoute<UserDetailRouteProp>();
  const navigation = useNavigation();
  const { userId, userName, userAvatar } = route.params || ({} as any);
  const { user } = useAuth();
  const { name: liveName, avatar: liveAvatar } = useDisplayProfile(
    userId,
    userName,
    userAvatar,
  );
  const [name, setName] = useState<string>(liveName || "ユーザー");
  const [avatar, setAvatar] = useState<string | undefined>(liveAvatar);
  const [following, setFollowing] = useState<boolean>(false);
  const [postsData, setPostsData] = useState<FirestoreCommunityPost[]>([]);
  const [loadingMore, setLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [blocked, setBlocked] = useState<boolean>(false);
  const [likedPosts, setLikedPosts] = useState<Set<string>>(new Set());
  const [showReplyButtons, setShowReplyButtons] = useState<Set<string>>(
    new Set(),
  );
  const [replyingTo, setReplyingTo] = useState<string | null>(null);
  const [replyText, setReplyText] = useState("");
  const [replyCounts, setReplyCounts] = useState<Map<string, number>>(
    new Map(),
  );
  const [averageDays, setAverageDays] = useState(0);
  const [likingIds, setLikingIds] = useState<Set<string>>(new Set());
  const [followersCount, setFollowersCount] = useState(0);
  const [followingCount, setFollowingCount] = useState(0);
  const { requireAuth } = useAuthPrompt();
  // 相対時間表示は各セル内の RelativeTime コンポーネントで個別に更新
  // 相対時間更新は各セル側で行うため、画面全体の毎秒再レンダは不要

  // Recompute rank on focus to keep consistency with post lists
  useFocusEffect(
    useCallback(() => {
      let mounted = true;
      (async () => {
        try {
          const days = await UserStatsService.getUserCurrentDaysForRank(userId);
          if (mounted) setAverageDays(days);
        } catch { }
        try {
          const c = await FollowService.getCounts(userId);
          if (mounted) {
            setFollowingCount(c.following);
            setFollowersCount(c.followers);
          }
        } catch { }
      })();
      return () => {
        mounted = false;
      };
    }, [userId]),
  );

  useEffect(() => {
    setName(liveName || "ユーザー");
    setAvatar(liveAvatar);
    if (!userId) return;
    (async () => {
      const days = await UserStatsService.getUserCurrentDaysForRank(userId).catch(() => 0);
      setAverageDays(days);
    })();
  }, [userId, liveName, liveAvatar]);

  // Fallback: if profile avatar is missing, borrow latest from posts snapshot
  useEffect(() => {
    if (!avatar) {
      const a = postsData.find((p) => p.authorAvatar)?.authorAvatar;
      if (a) setAvatar(a);
    }
  }, [postsData, avatar]);

  // Initialize LikeStore from server state once; do not override user taps
  useEffect(() => {
    let timer: any | undefined;
    (async () => {
      try {
        const { LikeStore } = await import("@shared/state/likeStore");
        // 16ms 以内に来た更新をまとめて反映
        const apply = () => {
          postsData.forEach((p) => {
            LikeStore.setFromServer(p.id, {
              isLiked: likedPosts.has(p.id),
              likes: p.likes || 0,
            });
          });
          timer = undefined;
        };
        if (!timer) timer = setTimeout(apply, 16);
      } catch { }
    })();
    return () => { if (timer) clearTimeout(timer); };
  }, [likedPosts, postsData]);
  useEffect(() => {
    let unsubscribe: (() => void) | undefined;
    let mounted = true;

    (async () => {
      try {
        const isFollowing = await FollowService.isFollowing(userId);
        if (mounted) setFollowing(isFollowing);
      } catch { }

      try {
        const isBlocked = await BlockService.isBlocked(userId);
        if (mounted) setBlocked(isBlocked);
      } catch { }

      try {
        const c = await FollowService.getCounts(userId);
        if (mounted) {
          setFollowingCount(c.following);
          setFollowersCount(c.followers);
        }
      } catch { }

      try {
        unsubscribe = CommunityService.subscribeToUserPosts(
          userId,
          async (list) => {
            const normalized = normalizeCommunityPostsFirestore(list);

            // 返信の取得はトークアイコン押下時に行うため、
            // ここでは Firestore から返信一覧を取得しない。
            // 表示用の件数は投稿の `comments` を利用する。
            const counts = buildReplyCountMapFromPosts(normalized);

            setReplyCounts(counts);
            setPostsData(normalized);

            if (user) {
              try {
                const ids = normalized.map((p) => p.id);
                const set = await CommunityService.getLikedPostIds(user.uid, ids);
                setLikedPosts(set);
              } catch { }
            }
          },
        );
      } catch { }
    })();

    return () => {
      mounted = false;
      if (unsubscribe) unsubscribe();
    };
  }, [userId, user]);

  const handlePostPress = (post: FirestoreCommunityPost) => {
    navigateToUserDetail(
      navigation,
      post.authorId,
      post.authorName,
      post.authorAvatar,
    );
  };

  const handleLike = async (postId: string) => {
    const ok = await requireAuth();
    if (!ok) return;
    if (likingIds.has(postId)) return;
    setLikingIds((prev) => new Set(prev).add(postId));
    try {
      await CommunityService.toggleLike(postId);
    } catch (e) {
      console.warn("like toggle failed", e);
    } finally {
      setLikingIds((prev) => {
        const s = new Set(prev);
        s.delete(postId);
        return s;
      });
    }
  };

  const handleComment = (postId: string) => {
    try {
      const {
        ReplyVisibilityStore,
      } = require("@shared/state/replyVisibilityStore");
      ReplyVisibilityStore.toggle(postId);
    } catch { }
  };

  const handleReply = async (postId: string) => {
    const ok = await requireAuth();
    if (!ok) return;
    setReplyingTo(postId);
    setReplyText("");
  };

  const handleReplySubmit = async () => {
    if (!replyingTo || !replyText.trim()) return;
    const ok = await requireAuth();
    if (!ok) return;
    try {
      await CommunityService.addReply(replyingTo, {
        content: replyText.trim(),
      });
      setReplyCounts((prev) => incrementCountMap(prev, replyingTo, 1));
      // Update minimal UI: just the bubble count for this post
      try {
        const { ReplyCountStore } = await import("@shared/state/replyStore");
        ReplyCountStore.increment(replyingTo, 1);
      } catch { }
      setReplyingTo(null);
      setReplyText("");
    } catch (e) {
      console.warn("reply failed", e);
    }
  };

  const handleReplyCancel = () => {
    setReplyingTo(null);
    setReplyText("");
  };

  // PostList が各種描画を担当

  const onToggleFollow = async () => {
    try {
      const ok = await requireAuth();
      if (!ok) return;
      if (following) {
        // Optimistic update
        FollowStore.remove(userId);
        await FollowService.unfollow(userId);
        setFollowing(false);
        setFollowersCount((n) => Math.max(0, n - 1));
      } else {
        // Optimistic update
        FollowStore.add(userId);
        await FollowService.follow(userId);
        setFollowing(true);
        setFollowersCount((n) => n + 1);
      }
    } catch (e) {
      console.warn("follow toggle failed", e);
    }
  };

  const onToggleBlock = async () => {
    try {
      const ok = await requireAuth();
      if (!ok) return;
      const wasFollowing = following;
      if (blocked) {
        // Optimistic
        BlockStore.remove(userId);
        await BlockService.unblock(userId);
        setBlocked(false);
      } else {
        // Optimistic
        BlockStore.add(userId);
        await BlockService.block(userId);
        setBlocked(true);
        // Also reflect follow state locally; block will unfollow on server
        setFollowing(false);
        try {
          FollowStore.remove(userId);
        } catch { }
        if (wasFollowing) {
          setFollowersCount((n) => Math.max(0, n - 1));
        }
      }
    } catch (e) {
      console.warn("block toggle failed", e);
    }
  };

  // 相対時間は共通関数を使用

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>プロフィール</Text>
        <View style={{ width: 32 }} />
      </View>

      {/* プロフィールヘッダーは PostList の ListHeaderComponent に移動し、スクロールに追従させる */}

      {/* 投稿一覧 */}
      <PostList
        posts={postsData}
        likedPosts={likedPosts}
        showReplyButtons={showReplyButtons}
        hasMore={false}
        replyCounts={replyCounts}
        authorAverageDays={averageDays}
        allowBlockedReplies={true}
        headerComponent={(
          <View>
            <View style={styles.profileHeaderCenter}>
              <AvatarImage
                uri={avatar}
                size={88}
                style={styles.profileAvatar}
              />
              <Text style={styles.profileName} numberOfLines={1}>
                {name}
              </Text>
              <Text style={styles.profileRank} numberOfLines={1}>
                {getRankDisplayByDays(averageDays)}
              </Text>
            </View>

            {user?.uid !== userId && (
              <View style={styles.ctaRow}>
                <TouchableOpacity
                  activeOpacity={0.8}
                  onPress={onToggleFollow}
                  style={[styles.primaryCta, following && styles.primaryCtaActive]}
                >
                  <Ionicons
                    name={following ? "checkmark" : "person-add-outline"}
                    size={18}
                    color={colors.black}
                    style={styles.ctaIcon}
                  />
                  <Text style={styles.primaryCtaText}>
                    {following ? "フォロー中" : "フォロー"}
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  activeOpacity={0.8}
                  onPress={onToggleBlock}
                  style={[styles.ghostCta, blocked && styles.ghostCtaActive]}
                >
                  <Ionicons
                    name={blocked ? "close-circle" : "remove-circle-outline"}
                    size={18}
                    color={blocked ? colors.gray800 : colors.textSecondary}
                    style={styles.ctaIcon}
                  />
                  <Text
                    style={[
                      styles.ghostCtaText,
                      blocked && styles.ghostCtaTextActive,
                    ]}
                  >
                    {blocked ? "ブロック中" : "ブロック"}
                  </Text>
                </TouchableOpacity>
              </View>
            )}

            {/* 投稿/フォロー/フォロワー カウント（余計な隙間を作らないため Divider は置かない） */}
            <View style={styles.statsRow}>
              <View style={styles.statItem}>
                <Text style={styles.statNumber}>{postsData.length}</Text>
                <Text style={styles.statLabel}>投稿</Text>
              </View>
              <View style={styles.statDivider} />
              <TouchableOpacity
                style={styles.statItem}
                activeOpacity={0.8}
                onPress={() =>
                  (navigation as any).navigate("FollowList", {
                    userId,
                    userName: name,
                    mode: "following",
                  })
                }
              >
                <Text style={styles.statNumber}>{followingCount}</Text>
                <Text style={styles.statLabel}>フォロー</Text>
              </TouchableOpacity>
              <View style={styles.statDivider} />
              <TouchableOpacity
                style={styles.statItem}
                activeOpacity={0.8}
                onPress={() =>
                  (navigation as any).navigate("FollowList", {
                    userId,
                    userName: name,
                    mode: "followers",
                  })
                }
              >
                <Text style={styles.statNumber}>{followersCount}</Text>
                <Text style={styles.statLabel}>フォロワー</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
        onLike={(id) => {
          void handleLike(id);
        }}
        onComment={handleComment}
        onReply={handleReply}
        onUserPress={(uid, uname) =>
          handlePostPress({ authorId: uid, authorName: uname } as any)
        }
        listStyle={{ flex: 1 }}
        contentContainerStyle={uiStyles.listContainer}
        onEndReached={() => {
          if (!hasMore || loadingMore || postsData.length === 0) return;
          // TODO: ページング対応を実装
        }}
        loadingMore={loadingMore}
      />

      {/* 返信入力フィールド */}
      {replyingTo && (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "padding"}
          keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 16}
        >
          <ReplyInputBar
            value={replyText}
            onChangeText={setReplyText}
            onCancel={handleReplyCancel}
            onSubmit={handleReplySubmit}
            autoFocus
          />
        </KeyboardAvoidingView>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: { padding: spacing.sm },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  listContainer: {
    backgroundColor: colors.white,
  },
  empty: {
    paddingVertical: spacing["3xl"],
    alignItems: "center",
  },
  emptyText: {
    color: colors.textSecondary,
  },
  // 新しいプロフィールヘッダー（縦並び: アイコン → 名前 → 階級）
  profileHeaderCenter: {
    alignItems: "center",
    paddingHorizontal: spacing.xl,
    paddingTop: spacing["2xl"],
    paddingBottom: spacing.lg,
    backgroundColor: colors.white,
  },
  profileAvatar: {
    marginBottom: spacing.md,
  },
  profileName: {
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  profileRank: {
    marginTop: 4,
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
    fontWeight: "500",
  },
  // CTA 行（左: フォロー[黄塗り] 右: ブロック[枠線のみ]）
  ctaRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: spacing.md,
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing.md,
    backgroundColor: colors.white,
  },
  primaryCta: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#FACC15", // amber-400 に近い黄
    borderRadius: 28,
    paddingVertical: 10,
  },
  primaryCtaActive: {
    backgroundColor: "#FDE047", // amber-300 っぽい薄黄（フォロー中）
  },
  primaryCtaText: {
    color: colors.black,
    fontSize: typography.fontSize.base,
    fontWeight: "700",
  },
  ghostCta: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: colors.white,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 28,
    paddingVertical: 10,
  },
  ghostCtaActive: {
    backgroundColor: "#E5E7EB",
    borderColor: "#CBD5E1",
  },
  ghostCtaText: {
    color: colors.textSecondary,
    fontSize: typography.fontSize.base,
    fontWeight: "700",
  },
  ghostCtaTextActive: {
    color: colors.gray800,
  },
  ctaIcon: {
    marginRight: 8,
  },
  // 旧スタイル（参照用）
  actionsRow: { flexDirection: "row", alignItems: "center", gap: spacing.sm },
  userProfileContainer: {
    flex: 1,
    marginRight: spacing.sm,
  },
  followBtn: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: spacing.md,
    paddingVertical: 4,
    minHeight: 28,
    borderColor: "#F87171",
    backgroundColor: colors.white,
  },
  followText: {
    color: "#F87171",
    fontSize: typography.fontSize.xs,
    fontWeight: "600",
  },
  follow: {
    backgroundColor: colors.white,
  },
  following: {
    backgroundColor: "#FDE2E2",
  },
  followingText: {
    color: "#EF4444",
    fontWeight: "700",
  },
  blockBtn: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: spacing.md,
    paddingVertical: 4,
    minHeight: 28,
  },
  blockText: {
    color: colors.textSecondary,
    fontSize: typography.fontSize.xs,
    fontWeight: "600",
  },
  block: {
    backgroundColor: colors.white,
    borderColor: colors.borderPrimary,
  },
  blocking: {
    backgroundColor: "#E5E7EB",
    borderColor: "#9CA3AF",
  },
  blockingText: {
    color: colors.gray800,
    fontWeight: "700",
  },
  divider: {
    height: 8,
    backgroundColor: colors.backgroundTertiary,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: colors.borderPrimary,
  },
  postItem: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  postHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  postAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: spacing.md,
  },
  postAvatarPlaceholder: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: colors.gray100,
    alignItems: "center",
    justifyContent: "center",
    marginRight: spacing.md,
  },
  postAvatarInitial: { fontWeight: "700", color: colors.textSecondary },
  postAuthor: {
    fontSize: typography.fontSize.base,
    fontWeight: "700",
    color: colors.gray800,
  },
  postDot: { marginHorizontal: 6, color: colors.textSecondary },
  postTime: { fontSize: typography.fontSize.sm, color: colors.textSecondary },
  postContent: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    lineHeight: 22,
    marginBottom: spacing.sm,
    marginLeft: 56,
  }, // アバター40px + マージン16px = 56px
  postActions: { flexDirection: "row", alignItems: "center", marginLeft: 56 }, // アバター40px + マージン16px = 56px
  postAction: {
    flexDirection: "row",
    alignItems: "center",
    marginRight: spacing["3xl"],
  },
  postActionText: { marginLeft: 6, color: colors.textSecondary },
  replyInputContainer: {
    backgroundColor: colors.gray50,
    padding: spacing.lg,
    borderTopWidth: 1,
    borderTopColor: colors.borderPrimary,
  },
  replyInput: {
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    backgroundColor: colors.white,
    borderRadius: 12,
    padding: spacing.md,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    minHeight: 80,
    textAlignVertical: "top",
    marginBottom: spacing.md,
  },
  replyInputActions: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    gap: spacing.md,
  },
  replyCancelButton: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
  },
  replyCancelText: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    fontWeight: typography.fontWeight.medium as any,
  },
  replySubmitButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    borderRadius: 20,
    minWidth: 60,
    alignItems: "center",
  },
  replySubmitButtonDisabled: { backgroundColor: colors.gray300 },
  replySubmitText: {
    fontSize: typography.fontSize.sm,
    color: colors.white,
    fontWeight: typography.fontWeight.semibold as any,
  },
  replySubmitTextDisabled: { color: colors.gray500 },
  // stats
  statsRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    backgroundColor: colors.white,
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.xl,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: colors.borderPrimary,
  },
  statItem: {
    flex: 1,
    alignItems: "center",
  },
  statNumber: {
    fontSize: typography.fontSize.lg,
    fontWeight: "700",
    color: colors.gray800,
  },
  statLabel: {
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
    marginTop: 2,
  },
  statDivider: {
    width: 1,
    alignSelf: "stretch",
    backgroundColor: colors.borderPrimary,
    marginHorizontal: spacing.lg,
    opacity: 0.6,
  },
});

export default UserDetailScreen;

*** Update File: src/features/profile/screens/ProfileScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { View, Text, StyleSheet, SafeAreaView, StatusBar, ScrollView, TouchableOpacity, Image, Alert } from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { supabase } from "@app/config/supabase.config";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import useProfileScreen from "@features/profile/hooks/useProfileScreen";
import Button from "@shared/components/Button";
import InputField from "@shared/components/InputField";
import Modal from "@shared/components/Modal";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { screenThemes } from "@shared/theme/screenThemes";
import { PurchasesService } from "@core/services/payments/purchasesService";

const ActionCard = ({
  icon,
  title,
  description,
  onPress,
}: {
  icon: keyof typeof Ionicons.glyphMap;
  title: string;
  description?: string;
  onPress: () => void | Promise<void>;
}) => (
  <TouchableOpacity
    activeOpacity={0.85}
    style={styles.actionCard}
    onPress={() => {
      void onPress();
    }}
  >
    <View style={styles.actionIconWrap}>
      <Ionicons name={icon} size={22} color={colors.info} />
    </View>
    <View style={styles.actionTextWrap}>
      <Text style={styles.actionTitle}>{title}</Text>
      {description ? (
        <Text style={styles.actionDesc}>{description}</Text>
      ) : null}
    </View>
    <Ionicons name="chevron-forward" size={20} color={colors.textSecondary} />
  </TouchableOpacity>
);

const Section = ({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) => (
  <View style={styles.section}>
    <Text style={styles.sectionTitle}>{title}</Text>
    <View style={styles.sectionBody}>{children}</View>
  </View>
);

const ProfileScreen: React.FC = () => {
  const { user } = useAuth();
  const [state, actions] = useProfileScreen();
  const navigation = useNavigation<StackNavigationProp<RootStackParamList>>();
  const { isEditing, editName, editAvatar, loading, showAvatarModal } = state;
  const [showLogoutConfirm, setShowLogoutConfirm] = React.useState(false);
  const {
    setShowAvatarModal,
    handleStartEdit,
    handleCancelEdit,
    handleSaveProfile,
    handleAvatarPress,
    handleImagePicker,
    handleRemoveImage,
    setEditName,
  } = actions;

  if (!user) {
    return (
      <SafeAreaView style={styles.container}>
        <StatusBar
          barStyle="dark-content"
          backgroundColor={colors.backgroundTertiary}
        />
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>読み込み中...</Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        {isEditing ? (
          <View style={styles.profileCard}>
            <View style={styles.avatarContainer}>
              <TouchableOpacity
                onPress={() => {
                  void handleImagePicker();
                }}
                style={styles.avatarEditContainer}
              >
                {editAvatar ? (
                  <>
                    <Image source={{ uri: editAvatar }} style={styles.avatar} />
                    <TouchableOpacity
                      onPress={handleRemoveImage}
                      style={[styles.overlayButton, styles.removeIconOverlay]}
                      accessibilityLabel="画像を削除"
                    >
                      <Ionicons name="close" size={18} color="white" />
                    </TouchableOpacity>
                  </>
                ) : (
                  <View style={styles.avatarPlaceholder}>
                    <Ionicons name="camera-outline" size={32} color="#9CA3AF" />
                    <Text style={styles.placeholderText}>
                      タップして{"\n"}写真を選択
                    </Text>
                  </View>
                )}
                <View style={[styles.overlayButton, styles.editIconOverlay]}>
                  <Ionicons name="pencil" size={18} color="white" />
                </View>
              </TouchableOpacity>
            </View>

            <View style={styles.nameEditContainer}>
              <InputField
                label=""
                value={editName}
                onChangeText={setEditName}
                placeholder="ユーザー名を入力（8文字以内）"
                style={styles.nameInput}
                textStyle={styles.nameInputText}
                maxLength={8}
                unstyled
              />
              <Text style={styles.characterCount}>{editName.length}/8</Text>
            </View>

            <View style={styles.editButtons}>
              <Button
                title="キャンセル"
                onPress={handleCancelEdit}
                variant="secondary"
                style={styles.editButton}
              />
              <Button
                title="保存"
                onPress={() => {
                  void handleSaveProfile();
                }}
                variant="primary"
                style={styles.saveButton}
                loading={loading}
              />
            </View>
          </View>
        ) : (
          <View style={styles.settingsContainer}>
            <View style={styles.actionGrid}>
              <Section title="アカウント">
                <ActionCard
                  icon="pencil"
                  title="プロフィールを編集"
                  description="名前や画像を変更できます"
                  onPress={handleStartEdit}
                />
                <ActionCard
                  icon="log-out-outline"
                  title="ログアウト"
                  description="サインアウトしてログイン画面に戻ります"
                  onPress={() => { setShowLogoutConfirm(true); }}
                />
              </Section>
              <Section title="プライバシー">
                <ActionCard
                  icon="hand-left-outline"
                  title="ブロック中のユーザー"
                  description="ブロックしたユーザーの一覧を表示"
                  onPress={() => {
                    void navigation.navigate("BlockedUsers");
                  }}
                />
              </Section>
              <Section title="サポート">
                <ActionCard
                  icon="mail-outline"
                  title="開発者へフィードバック"
                  description="不具合報告・改善提案を送信"
                  onPress={() => {
                    void navigation.navigate("Feedback");
                  }}
                />
                <ActionCard
                  icon="refresh"
                  title="購入の復元"
                  description="機種変更などで購入が反映されない場合"
                  onPress={async () => {
                    try {
                      await PurchasesService.restore();
                      try {
                        const { Platform } = await import('react-native');
                        await (await import('@core/services/firestore/paymentService')).PaymentFirestoreService.addPaymentLog({ event: 'restore', status: 'success', platform: (Platform as any)?.OS });
                      } catch { }
                      Alert.alert("復元完了", "購入情報を復元しました。");
                    } catch (e: any) {
                      try {
                        const { Platform } = await import('react-native');
                        await (await import('@core/services/firestore/paymentService')).PaymentFirestoreService.addPaymentLog({ event: 'restore', status: 'error', platform: (Platform as any)?.OS, errorMessage: e?.message || String(e) });
                      } catch { }
                      Alert.alert("エラー", e?.message || "復元に失敗しました");
                    }
                  }}
                />
              </Section>
            </View>
          </View>
        )}
      </ScrollView>

      {/* アバタープレビュー */}
      <Modal
        visible={showAvatarModal}
        onClose={() => setShowAvatarModal(false)}
        title="プロフィール画像"
      >
        <View style={{ alignItems: "center" }}>
          {user?.avatarUrl ? (
            <Image
              source={{ uri: user.avatarUrl }}
              style={styles.avatarPreview}
            />
          ) : null}
          <View style={styles.editButtons}>
            <Button
              title="変更する"
              onPress={() => {
                void (async () => {
                  setShowAvatarModal(false);
                  handleStartEdit();
                  await handleImagePicker();
                })();
              }}
              style={styles.editButton}
            />
            {user?.avatarUrl ? (
              <Button
                title="削除"
                onPress={() => {
                  setShowAvatarModal(false);
                  handleStartEdit();
                  handleRemoveImage();
                }}
                variant="danger"
                style={styles.editButton}
              />
            ) : null}
          </View>
        </View>
      </Modal>

      {/* ログアウト確認モーダル（Figmaスタイル） */}
      <ConfirmDialog
        visible={showLogoutConfirm}
        onClose={() => setShowLogoutConfirm(false)}
        title="ログアウトしますか？"
        description="アカウントからサインアウトします。よろしいですか？"
        icon="log-out-outline"
        tone="danger"
        secondaryLabel="キャンセル"
        primaryLabel="ログアウト"
        onSecondary={() => setShowLogoutConfirm(false)}
        onPrimary={async () => {
          try { await supabase.auth.signOut(); } catch { }
        }}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  scrollView: {
    flex: 1,
  },
  settingsContainer: {
    paddingHorizontal: spacing.xl,
    paddingTop: spacing.xl,
    paddingBottom: spacing.xl,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  loadingText: {
    fontSize: typography.fontSize.base,
    color: colors.textSecondary,
  },
  profileCard: {
    backgroundColor: colors.white,
    marginHorizontal: spacing.xl,
    marginTop: spacing.xl,
    marginBottom: spacing.xl,
    borderRadius: 20,
    padding: spacing["2xl"],
    paddingTop: 40,
    paddingBottom: 28,
    alignItems: "center",
    minHeight: 320,
    ...shadows.lg,
  },
  actionGrid: {
    width: "100%",
    marginTop: 18,
    paddingHorizontal: spacing.lg,
    gap: 12,
  },
  section: {
    marginBottom: spacing.lg,
  },
  sectionTitle: {
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
    color: colors.textSecondary,
    marginLeft: spacing.md,
    marginBottom: 6,
  },
  sectionBody: {
    gap: 10,
  },
  actionCard: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: colors.white,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 14,
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.lg,
    ...shadows.base,
  },
  actionIconWrap: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: screenThemes.profile.tintSoft,
    alignItems: "center",
    justifyContent: "center",
    marginRight: spacing.md,
  },
  actionTextWrap: {
    flex: 1,
  },
  actionTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.gray800,
  },
  actionDesc: {
    marginTop: 2,
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
  },
  avatarContainer: {
    marginTop: 8,
    marginBottom: 9,
  },
  avatar: {
    width: 96,
    height: 96,
    borderRadius: 48,
    borderWidth: 3,
    borderColor: colors.borderPrimary,
  },
  avatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 3,
    borderStyle: "dashed",
    borderColor: colors.info,
    backgroundColor: screenThemes.profile.tintSoft,
    justifyContent: "center",
    alignItems: "center",
  },
  placeholderText: {
    color: colors.textSecondary,
    fontSize: 13,
    textAlign: "center",
    marginTop: spacing.sm,
    lineHeight: 16,
  },
  defaultAvatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
  },
  avatarText: {
    fontSize: 32,
    fontWeight: "bold",
    color: colors.white,
  },
  avatarPreview: {
    width: 240,
    height: 240,
    borderRadius: 120,
    marginBottom: spacing.lg,
  },
  userName: {
    fontSize: 22,
    fontWeight: "bold",
    color: colors.gray800,
    marginTop: spacing.sm,
    marginBottom: 9,
  },
  userNameEditing: {
    textDecorationLine: "underline",
    textDecorationColor: colors.info,
    textDecorationStyle: "solid",
  },
  editButton: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    backgroundColor: colors.gray100,
    borderRadius: 20,
    marginHorizontal: spacing.md,
  },
  editButtonText: {
    marginLeft: 4,
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
    color: colors.info,
  },
  editButtons: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: spacing["2xl"],
  },
  singleActionWrapper: {
    width: "100%",
    alignItems: "center",
    marginTop: 18,
    marginBottom: 0,
  },
  primaryCTA: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    minWidth: 220,
    borderRadius: 24,
    backgroundColor: colors.info,
    shadowColor: colors.info,
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 6,
  },
  avatarEditContainer: {
    position: "relative",
  },
  overlayButton: {
    position: "absolute",
    borderRadius: 16,
    width: 32,
    height: 32,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 2,
    borderColor: colors.white,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 6,
  },
  editIconOverlay: {
    bottom: -6,
    right: -6,
    backgroundColor: colors.info,
    shadowColor: colors.info,
  },
  removeIconOverlay: {
    top: -6,
    left: -6,
    backgroundColor: colors.error,
    shadowColor: colors.error,
  },
  nameEditContainer: {
    width: "100%",
    marginTop: 6,
    marginBottom: 6,
  },
  nameInput: {
    backgroundColor: "transparent",
    borderWidth: 0,
    paddingHorizontal: 0,
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
    alignSelf: "center",
    width: "70%",
    paddingBottom: spacing.xs,
  },
  nameInputText: {
    fontSize: 20,
    fontWeight: "bold",
    color: colors.gray800,
    textAlign: "center",
  },
  characterCount: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    marginTop: spacing.xs,
    textAlign: "center",
  },
  saveButton: {
    backgroundColor: colors.info,
    paddingHorizontal: 20,
    paddingVertical: 10,
    minWidth: 100,
    borderRadius: 22,
  },
  actionButtons: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: 12,
    gap: 12,
  },
  actionButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    minWidth: 90,
  },
});

export default ProfileScreen;

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { View, Text, StyleSheet, SafeAreaView, StatusBar, ScrollView, TouchableOpacity, Image, Alert } from "react-native";

import { useAuth } from "@app/contexts/AuthContext";
import { supabase } from "@app/config/supabase.config";
import type { RootStackParamList } from "@app/navigation/RootNavigator";
import useProfileScreen from "@features/profile/hooks/useProfileScreen";
import Button from "@shared/components/Button";
import InputField from "@shared/components/InputField";
import Modal from "@shared/components/Modal";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { screenThemes } from "@shared/theme/screenThemes";
import { PurchasesService } from "@core/services/payments/purchasesService";

const ActionCard = ({
  icon,
  title,
  description,
  onPress,
}: {
  icon: keyof typeof Ionicons.glyphMap;
  title: string;
  description?: string;
  onPress: () => void | Promise<void>;
}) => (
  <TouchableOpacity
    activeOpacity={0.85}
    style={styles.actionCard}
    onPress={() => {
      void onPress();
    }}
  >
    <View style={styles.actionIconWrap}>
      <Ionicons name={icon} size={22} color={colors.info} />
    </View>
    <View style={styles.actionTextWrap}>
      <Text style={styles.actionTitle}>{title}</Text>
      {description ? (
        <Text style={styles.actionDesc}>{description}</Text>
      ) : null}
    </View>
    <Ionicons name="chevron-forward" size={20} color={colors.textSecondary} />
  </TouchableOpacity>
);

const Section = ({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) => (
  <View style={styles.section}>
    <Text style={styles.sectionTitle}>{title}</Text>
    <View style={styles.sectionBody}>{children}</View>
  </View>
);

const ProfileScreen: React.FC = () => {
  const { user } = useAuth();
  const [state, actions] = useProfileScreen();
  const navigation = useNavigation<StackNavigationProp<RootStackParamList>>();
  const { isEditing, editName, editAvatar, loading, showAvatarModal } = state;
  const [showLogoutConfirm, setShowLogoutConfirm] = React.useState(false);
  const {
    setShowAvatarModal,
    handleStartEdit,
    handleCancelEdit,
    handleSaveProfile,
    handleAvatarPress,
    handleImagePicker,
    handleRemoveImage,
    setEditName,
  } = actions;

  if (!user) {
    return (
      <SafeAreaView style={styles.container}>
        <AppStatusBar />
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>読み込み中...</Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        {isEditing ? (
          <View style={styles.profileCard}>
            <View style={styles.avatarContainer}>
              <TouchableOpacity
                onPress={() => {
                  void handleImagePicker();
                }}
                style={styles.avatarEditContainer}
              >
                {editAvatar ? (
                  <>
                    <Image source={{ uri: editAvatar }} style={styles.avatar} />
                    <TouchableOpacity
                      onPress={handleRemoveImage}
                      style={[styles.overlayButton, styles.removeIconOverlay]}
                      accessibilityLabel="画像を削除"
                    >
                      <Ionicons name="close" size={18} color="white" />
                    </TouchableOpacity>
                  </>
                ) : (
                  <View style={styles.avatarPlaceholder}>
                    <Ionicons name="camera-outline" size={32} color="#9CA3AF" />
                    <Text style={styles.placeholderText}>
                      タップして{"\n"}写真を選択
                    </Text>
                  </View>
                )}
                <View style={[styles.overlayButton, styles.editIconOverlay]}>
                  <Ionicons name="pencil" size={18} color="white" />
                </View>
              </TouchableOpacity>
            </View>

            <View style={styles.nameEditContainer}>
              <InputField
                label=""
                value={editName}
                onChangeText={setEditName}
                placeholder="ユーザー名を入力（8文字以内）"
                style={styles.nameInput}
                textStyle={styles.nameInputText}
                maxLength={8}
                unstyled
              />
              <Text style={styles.characterCount}>{editName.length}/8</Text>
            </View>

            <View style={styles.editButtons}>
              <Button
                title="キャンセル"
                onPress={handleCancelEdit}
                variant="secondary"
                style={styles.editButton}
              />
              <Button
                title="保存"
                onPress={() => {
                  void handleSaveProfile();
                }}
                variant="primary"
                style={styles.saveButton}
                loading={loading}
              />
            </View>
          </View>
        ) : (
          <View style={styles.settingsContainer}>
            <View style={styles.actionGrid}>
              <Section title="アカウント">
                <ActionCard
                  icon="pencil"
                  title="プロフィールを編集"
                  description="名前や画像を変更できます"
                  onPress={handleStartEdit}
                />
                <ActionCard
                  icon="log-out-outline"
                  title="ログアウト"
                  description="サインアウトしてログイン画面に戻ります"
                  onPress={() => { setShowLogoutConfirm(true); }}
                />
              </Section>
              <Section title="プライバシー">
                <ActionCard
                  icon="hand-left-outline"
                  title="ブロック中のユーザー"
                  description="ブロックしたユーザーの一覧を表示"
                  onPress={() => {
                    void navigation.navigate("BlockedUsers");
                  }}
                />
              </Section>
              <Section title="サポート">
                <ActionCard
                  icon="mail-outline"
                  title="開発者へフィードバック"
                  description="不具合報告・改善提案を送信"
                  onPress={() => {
                    void navigation.navigate("Feedback");
                  }}
                />
                <ActionCard
                  icon="refresh"
                  title="購入の復元"
                  description="機種変更などで購入が反映されない場合"
                  onPress={async () => {
                    try {
                      await PurchasesService.restore();
                      try {
                        const { Platform } = await import('react-native');
                        await (await import('@core/services/firestore/paymentService')).PaymentFirestoreService.addPaymentLog({ event: 'restore', status: 'success', platform: (Platform as any)?.OS });
                      } catch { }
                      Alert.alert("復元完了", "購入情報を復元しました。");
                    } catch (e: any) {
                      try {
                        const { Platform } = await import('react-native');
                        await (await import('@core/services/firestore/paymentService')).PaymentFirestoreService.addPaymentLog({ event: 'restore', status: 'error', platform: (Platform as any)?.OS, errorMessage: e?.message || String(e) });
                      } catch { }
                      Alert.alert("エラー", e?.message || "復元に失敗しました");
                    }
                  }}
                />
              </Section>
            </View>
          </View>
        )}
      </ScrollView>

      {/* アバタープレビュー */}
      <Modal
        visible={showAvatarModal}
        onClose={() => setShowAvatarModal(false)}
        title="プロフィール画像"
      >
        <View style={{ alignItems: "center" }}>
          {user?.avatarUrl ? (
            <Image
              source={{ uri: user.avatarUrl }}
              style={styles.avatarPreview}
            />
          ) : null}
          <View style={styles.editButtons}>
            <Button
              title="変更する"
              onPress={() => {
                void (async () => {
                  setShowAvatarModal(false);
                  handleStartEdit();
                  await handleImagePicker();
                })();
              }}
              style={styles.editButton}
            />
            {user?.avatarUrl ? (
              <Button
                title="削除"
                onPress={() => {
                  setShowAvatarModal(false);
                  handleStartEdit();
                  handleRemoveImage();
                }}
                variant="danger"
                style={styles.editButton}
              />
            ) : null}
          </View>
        </View>
      </Modal>

      {/* ログアウト確認モーダル（Figmaスタイル） */}
      <ConfirmDialog
        visible={showLogoutConfirm}
        onClose={() => setShowLogoutConfirm(false)}
        title="ログアウトしますか？"
        description="アカウントからサインアウトします。よろしいですか？"
        icon="log-out-outline"
        tone="danger"
        secondaryLabel="キャンセル"
        primaryLabel="ログアウト"
        onSecondary={() => setShowLogoutConfirm(false)}
        onPrimary={async () => {
          try { await supabase.auth.signOut(); } catch { }
        }}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  scrollView: {
    flex: 1,
  },
  settingsContainer: {
    paddingHorizontal: spacing.xl,
    paddingTop: spacing.xl,
    paddingBottom: spacing.xl,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  loadingText: {
    fontSize: typography.fontSize.base,
    color: colors.textSecondary,
  },
  profileCard: {
    backgroundColor: colors.white,
    marginHorizontal: spacing.xl,
    marginTop: spacing.xl,
    marginBottom: spacing.xl,
    borderRadius: 20,
    padding: spacing["2xl"],
    paddingTop: 40,
    paddingBottom: 28,
    alignItems: "center",
    minHeight: 320,
    ...shadows.lg,
  },
  actionGrid: {
    width: "100%",
    marginTop: 18,
    paddingHorizontal: spacing.lg,
    gap: 12,
  },
  section: {
    marginBottom: spacing.lg,
  },
  sectionTitle: {
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
    color: colors.textSecondary,
    marginLeft: spacing.md,
    marginBottom: 6,
  },
  sectionBody: {
    gap: 10,
  },
  actionCard: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: colors.white,
    borderWidth: 1,
    borderColor: colors.borderPrimary,
    borderRadius: 14,
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.lg,
    ...shadows.base,
  },
  actionIconWrap: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: screenThemes.profile.tintSoft,
    alignItems: "center",
    justifyContent: "center",
    marginRight: spacing.md,
  },
  actionTextWrap: {
    flex: 1,
  },
  actionTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: "600",
    color: colors.gray800,
  },
  actionDesc: {
    marginTop: 2,
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
  },
  avatarContainer: {
    marginTop: 8,
    marginBottom: 9,
  },
  avatar: {
    width: 96,
    height: 96,
    borderRadius: 48,
    borderWidth: 3,
    borderColor: colors.borderPrimary,
  },
  avatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 3,
    borderStyle: "dashed",
    borderColor: colors.info,
    backgroundColor: screenThemes.profile.tintSoft,
    justifyContent: "center",
    alignItems: "center",
  },
  placeholderText: {
    color: colors.textSecondary,
    fontSize: 13,
    textAlign: "center",
    marginTop: spacing.sm,
    lineHeight: 16,
  },
  defaultAvatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
  },
  avatarText: {
    fontSize: 32,
    fontWeight: "bold",
    color: colors.white,
  },
  avatarPreview: {
    width: 240,
    height: 240,
    borderRadius: 120,
    marginBottom: spacing.lg,
  },
  userName: {
    fontSize: 22,
    fontWeight: "bold",
    color: colors.gray800,
    marginTop: spacing.sm,
    marginBottom: 9,
  },
  userNameEditing: {
    textDecorationLine: "underline",
    textDecorationColor: colors.info,
    textDecorationStyle: "solid",
  },
  editButton: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.sm,
    backgroundColor: colors.gray100,
    borderRadius: 20,
    marginHorizontal: spacing.md,
  },
  editButtonText: {
    marginLeft: 4,
    fontSize: typography.fontSize.sm,
    fontWeight: "600",
    color: colors.info,
  },
  editButtons: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: spacing["2xl"],
  },
  singleActionWrapper: {
    width: "100%",
    alignItems: "center",
    marginTop: 18,
    marginBottom: 0,
  },
  primaryCTA: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    minWidth: 220,
    borderRadius: 24,
    backgroundColor: colors.info,
    shadowColor: colors.info,
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 6,
  },
  avatarEditContainer: {
    position: "relative",
  },
  overlayButton: {
    position: "absolute",
    borderRadius: 16,
    width: 32,
    height: 32,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 2,
    borderColor: colors.white,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 6,
  },
  editIconOverlay: {
    bottom: -6,
    right: -6,
    backgroundColor: colors.info,
    shadowColor: colors.info,
  },
  removeIconOverlay: {
    top: -6,
    left: -6,
    backgroundColor: colors.error,
    shadowColor: colors.error,
  },
  nameEditContainer: {
    width: "100%",
    marginTop: 6,
    marginBottom: 6,
  },
  nameInput: {
    backgroundColor: "transparent",
    borderWidth: 0,
    paddingHorizontal: 0,
    borderBottomWidth: 2,
    borderBottomColor: colors.info,
    alignSelf: "center",
    width: "70%",
    paddingBottom: spacing.xs,
  },
  nameInputText: {
    fontSize: 20,
    fontWeight: "bold",
    color: colors.gray800,
    textAlign: "center",
  },
  characterCount: {
    fontSize: typography.fontSize.sm,
    color: colors.textSecondary,
    marginTop: spacing.xs,
    textAlign: "center",
  },
  saveButton: {
    backgroundColor: colors.info,
    paddingHorizontal: 20,
    paddingVertical: 10,
    minWidth: 100,
    borderRadius: 22,
  },
  actionButtons: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: 12,
    gap: 12,
  },
  actionButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    minWidth: 90,
  },
});

export default ProfileScreen;

*** Update File: src/features/profile/screens/FollowListScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import type { RouteProp } from "@react-navigation/native";
import { useNavigation, useRoute } from "@react-navigation/native";
import React, { useEffect, useMemo, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  FlatList,
} from "react-native";

import { FollowService } from "@core/services/firestore";
import ProfileCache from "@core/services/profileCache";
import AvatarImage from "@shared/components/AvatarImage";
import { colors, spacing, typography } from "@shared/theme";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { getRankDisplayByDays } from "@core/services/rankService";
import { UserStatsService } from "@core/services/userStatsService";
import { useAuth } from "@app/contexts/AuthContext";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";
import { FollowStore, useFollowingIds } from "@shared/state/followStore";

type ParamList = {
  FollowList: {
    userId: string;
    userName?: string;
    mode: "following" | "followers";
  };
};

type FollowListRouteProp = RouteProp<ParamList, "FollowList">;

const FollowListScreen: React.FC = () => {
  const navigation = useNavigation();
  const route = useRoute<FollowListRouteProp>();
  const { userId, userName, mode } = route.params || ({} as any);
  const { user } = useAuth();
  const followingSet = useFollowingIds();
  const { requireAuth } = useAuthPrompt();

  const title = mode === "following" ? "フォロー" : "フォロワー";
  const [ids, setIds] = useState<string[]>([]);
  const [profiles, setProfiles] = useState<Map<string, any>>(new Map());

  useEffect(() => {
    let unsubProfiles: (() => void) | undefined;
    let unsubFollow: (() => void) | undefined;
    let pollTimer: ReturnType<typeof setTimeout> | undefined;

    const attachProfiles = (list: string[]) => {
      setIds(list);
      if (unsubProfiles) unsubProfiles();
      unsubProfiles = ProfileCache.getInstance().subscribeMany(list, (map) => {
        setProfiles(map as any);
      });
    };

    const startPolling = () => {
      const tick = async () => {
        try {
          const list =
            mode === "following"
              ? await FollowService.getFollowingUserIds(userId)
              : await FollowService.getFollowerUserIds(userId);
          attachProfiles(list);
        } catch {
          // ignore
        } finally {
          pollTimer = setTimeout(tick, 5000);
        }
      };
      void tick();
    };

    if (mode === "following") {
      const fn: any = (FollowService as any).subscribeToFollowingUserIds;
      if (typeof fn === "function") {
        unsubFollow = fn(userId, attachProfiles);
      } else {
        startPolling();
      }
    } else {
      const fn: any = (FollowService as any).subscribeToFollowerUserIds;
      if (typeof fn === "function") {
        unsubFollow = fn(userId, attachProfiles);
      } else {
        startPolling();
      }
    }

    return () => {
      if (unsubProfiles) unsubProfiles();
      if (unsubFollow) unsubFollow();
      if (pollTimer) clearTimeout(pollTimer);
    };
  }, [userId, mode]);

  const data = useMemo(() => ids, [ids]);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor={colors.white} />
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{title}</Text>
        <View style={{ width: 32 }} />
      </View>

      <FlatList
        data={data}
        keyExtractor={(id) => id}
        contentContainerStyle={styles.listContent}
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        renderItem={({ item: id }) => {
          const p = profiles.get(id);
          const name = p?.displayName ?? "ユーザー";
          const avatar = p?.photoURL as string | undefined;
          const isMe = user?.uid === id;
          const isFollowing = followingSet.has(id);
          return (
            <View style={styles.item}>
              <TouchableOpacity
                activeOpacity={0.8}
                style={styles.itemMain}
                onPress={() =>
                  navigateToUserDetail(navigation as any, id, name, avatar)
                }
              >
                <AvatarImage uri={avatar} size={44} style={styles.itemAvatar} />
                <View style={{ flex: 1, minWidth: 0 }}>
                  <Text style={styles.itemName} numberOfLines={1}>
                    {name}
                  </Text>
                  <RankText userId={id} />
                </View>
              </TouchableOpacity>

              {!isMe && (
                <FollowPill
                  targetUserId={id}
                  isFollowing={isFollowing}
                  requireAuth={requireAuth}
                />
              )}
            </View>
          );
        }}
        ListEmptyComponent={() => (
          <View style={styles.empty}> 
            <Text style={styles.emptyText}>
              {mode === "following" ? "フォローしているユーザーがいません" : "フォロワーがいません"}
            </Text>
          </View>
        )}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: { padding: spacing.sm },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  listContent: {
    backgroundColor: colors.white,
  },
  separator: {
    height: 1,
    backgroundColor: colors.borderPrimary,
    marginLeft: spacing.xl + 44 + spacing.md, // 左のアバター分を空ける
  },
  item: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
  },
  itemMain: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
    marginRight: spacing.md,
  },
  itemAvatar: {
    marginRight: spacing.md,
  },
  itemName: {
    flex: 1,
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    fontWeight: "600",
  },
  itemSub: {
    marginTop: 2,
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
  },
  followPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.md,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 2,
    borderColor: "#FACC15",
    backgroundColor: colors.white,
  },
  followPillFollowing: {
    borderColor: "#FDE047",
    backgroundColor: colors.white,
  },
  followPillText: {
    fontSize: typography.fontSize.sm,
    color: colors.black,
    fontWeight: "700",
  },
  followIconWrap: {
    width: 18,
    height: 18,
    borderRadius: 9,
    backgroundColor: colors.black,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 8,
  },
  empty: {
    alignItems: "center",
    paddingVertical: spacing["3xl"],
  },
  emptyText: {
    color: colors.textSecondary,
  },
});

export default FollowListScreen;

// 下: 補助コンポーネント（1ユーザーの階級表示）
const RankText: React.FC<{ userId: string }> = ({ userId }) => {
  const [days, setDays] = useState<number>(0);
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const d = await UserStatsService.getUserCurrentDaysForRank(userId);
        if (mounted) setDays(d);
      } catch {
        if (mounted) setDays(0);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [userId]);
  return (
    <Text style={styles.itemSub} numberOfLines={1}>
      {getRankDisplayByDays(days)}
    </Text>
  );
};

const FollowPill: React.FC<{
  targetUserId: string;
  isFollowing: boolean;
  requireAuth: () => Promise<boolean>;
}> = ({ targetUserId, isFollowing, requireAuth }) => {
  const [busy, setBusy] = useState(false);
  const handlePress = async () => {
    if (busy) return;
    const ok = await requireAuth();
    if (!ok) return;
    setBusy(true);
    try {
      if (isFollowing) {
        FollowStore.remove(targetUserId);
        await FollowService.unfollow(targetUserId);
      } else {
        FollowStore.add(targetUserId);
        await FollowService.follow(targetUserId);
      }
    } catch {
      // ignore errors; UI will resync via subscription
    } finally {
      setBusy(false);
    }
  };
  return (
    <TouchableOpacity
      onPress={handlePress}
      activeOpacity={0.8}
      disabled={busy}
      style={[styles.followPill, isFollowing && styles.followPillFollowing]}
    >
      <View style={styles.followIconWrap}>
        <Ionicons name={isFollowing ? "checkmark" : "add"} size={12} color={colors.white} />
      </View>
      <Text style={styles.followPillText}>{isFollowing ? "フォロー中" : "フォローする"}</Text>
    </TouchableOpacity>
  );
};

+import { Ionicons } from "@expo/vector-icons";
import type { RouteProp } from "@react-navigation/native";
import { useNavigation, useRoute } from "@react-navigation/native";
import React, { useEffect, useMemo, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  FlatList,
} from "react-native";

import { FollowService } from "@core/services/firestore";
import ProfileCache from "@core/services/profileCache";
import AvatarImage from "@shared/components/AvatarImage";
import { colors, spacing, typography } from "@shared/theme";
import { navigateToUserDetail } from "@shared/utils/navigation";
import { getRankDisplayByDays } from "@core/services/rankService";
import { UserStatsService } from "@core/services/userStatsService";
import { useAuth } from "@app/contexts/AuthContext";
import { useAuthPrompt } from "@shared/auth/AuthPromptProvider";
import { FollowStore, useFollowingIds } from "@shared/state/followStore";

type ParamList = {
  FollowList: {
    userId: string;
    userName?: string;
    mode: "following" | "followers";
  };
};

type FollowListRouteProp = RouteProp<ParamList, "FollowList">;

const FollowListScreen: React.FC = () => {
  const navigation = useNavigation();
  const route = useRoute<FollowListRouteProp>();
  const { userId, userName, mode } = route.params || ({} as any);
  const { user } = useAuth();
  const followingSet = useFollowingIds();
  const { requireAuth } = useAuthPrompt();

  const title = mode === "following" ? "フォロー" : "フォロワー";
  const [ids, setIds] = useState<string[]>([]);
  const [profiles, setProfiles] = useState<Map<string, any>>(new Map());

  useEffect(() => {
    let unsubProfiles: (() => void) | undefined;
    let unsubFollow: (() => void) | undefined;
    let pollTimer: ReturnType<typeof setTimeout> | undefined;

    const attachProfiles = (list: string[]) => {
      setIds(list);
      if (unsubProfiles) unsubProfiles();
      unsubProfiles = ProfileCache.getInstance().subscribeMany(list, (map) => {
        setProfiles(map as any);
      });
    };

    const startPolling = () => {
      const tick = async () => {
        try {
          const list =
            mode === "following"
              ? await FollowService.getFollowingUserIds(userId)
              : await FollowService.getFollowerUserIds(userId);
          attachProfiles(list);
        } catch {
          // ignore
        } finally {
          pollTimer = setTimeout(tick, 5000);
        }
      };
      void tick();
    };

    if (mode === "following") {
      const fn: any = (FollowService as any).subscribeToFollowingUserIds;
      if (typeof fn === "function") {
        unsubFollow = fn(userId, attachProfiles);
      } else {
        startPolling();
      }
    } else {
      const fn: any = (FollowService as any).subscribeToFollowerUserIds;
      if (typeof fn === "function") {
        unsubFollow = fn(userId, attachProfiles);
      } else {
        startPolling();
      }
    }

    return () => {
      if (unsubProfiles) unsubProfiles();
      if (unsubFollow) unsubFollow();
      if (pollTimer) clearTimeout(pollTimer);
    };
  }, [userId, mode]);

  const data = useMemo(() => ids, [ids]);

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={22} color={colors.gray800} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{title}</Text>
        <View style={{ width: 32 }} />
      </View>

      <FlatList
        data={data}
        keyExtractor={(id) => id}
        contentContainerStyle={styles.listContent}
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        renderItem={({ item: id }) => {
          const p = profiles.get(id);
          const name = p?.displayName ?? "ユーザー";
          const avatar = p?.photoURL as string | undefined;
          const isMe = user?.uid === id;
          const isFollowing = followingSet.has(id);
          return (
            <View style={styles.item}>
              <TouchableOpacity
                activeOpacity={0.8}
                style={styles.itemMain}
                onPress={() =>
                  navigateToUserDetail(navigation as any, id, name, avatar)
                }
              >
                <AvatarImage uri={avatar} size={44} style={styles.itemAvatar} />
                <View style={{ flex: 1, minWidth: 0 }}>
                  <Text style={styles.itemName} numberOfLines={1}>
                    {name}
                  </Text>
                  <RankText userId={id} />
                </View>
              </TouchableOpacity>

              {!isMe && (
                <FollowPill
                  targetUserId={id}
                  isFollowing={isFollowing}
                  requireAuth={requireAuth}
                />
              )}
            </View>
          );
        }}
        ListEmptyComponent={() => (
          <View style={styles.empty}> 
            <Text style={styles.emptyText}>
              {mode === "following" ? "フォローしているユーザーがいません" : "フォロワーがいません"}
            </Text>
          </View>
        )}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  backButton: { padding: spacing.sm },
  headerTitle: {
    flex: 1,
    textAlign: "center",
    fontSize: typography.fontSize.lg,
    fontWeight: "bold",
    color: colors.gray800,
  },
  listContent: {
    backgroundColor: colors.white,
  },
  separator: {
    height: 1,
    backgroundColor: colors.borderPrimary,
    marginLeft: spacing.xl + 44 + spacing.md, // 左のアバター分を空ける
  },
  item: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
  },
  itemMain: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
    marginRight: spacing.md,
  },
  itemAvatar: {
    marginRight: spacing.md,
  },
  itemName: {
    flex: 1,
    fontSize: typography.fontSize.base,
    color: colors.textPrimary,
    fontWeight: "600",
  },
  itemSub: {
    marginTop: 2,
    fontSize: typography.fontSize.xs,
    color: colors.textSecondary,
  },
  followPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: spacing.md,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 2,
    borderColor: "#FACC15",
    backgroundColor: colors.white,
  },
  followPillFollowing: {
    borderColor: "#FDE047",
    backgroundColor: colors.white,
  },
  followPillText: {
    fontSize: typography.fontSize.sm,
    color: colors.black,
    fontWeight: "700",
  },
  followIconWrap: {
    width: 18,
    height: 18,
    borderRadius: 9,
    backgroundColor: colors.black,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 8,
  },
  empty: {
    alignItems: "center",
    paddingVertical: spacing["3xl"],
  },
  emptyText: {
    color: colors.textSecondary,
  },
});

export default FollowListScreen;

// 下: 補助コンポーネント（1ユーザーの階級表示）
const RankText: React.FC<{ userId: string }> = ({ userId }) => {
  const [days, setDays] = useState<number>(0);
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const d = await UserStatsService.getUserCurrentDaysForRank(userId);
        if (mounted) setDays(d);
      } catch {
        if (mounted) setDays(0);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [userId]);
  return (
    <Text style={styles.itemSub} numberOfLines={1}>
      {getRankDisplayByDays(days)}
    </Text>
  );
};

const FollowPill: React.FC<{
  targetUserId: string;
  isFollowing: boolean;
  requireAuth: () => Promise<boolean>;
}> = ({ targetUserId, isFollowing, requireAuth }) => {
  const [busy, setBusy] = useState(false);
  const handlePress = async () => {
    if (busy) return;
    const ok = await requireAuth();
    if (!ok) return;
    setBusy(true);
    try {
      if (isFollowing) {
        FollowStore.remove(targetUserId);
        await FollowService.unfollow(targetUserId);
      } else {
        FollowStore.add(targetUserId);
        await FollowService.follow(targetUserId);
      }
    } catch {
      // ignore errors; UI will resync via subscription
    } finally {
      setBusy(false);
    }
  };
  return (
    <TouchableOpacity
      onPress={handlePress}
      activeOpacity={0.8}
      disabled={busy}
      style={[styles.followPill, isFollowing && styles.followPillFollowing]}
    >
      <View style={styles.followIconWrap}>
        <Ionicons name={isFollowing ? "checkmark" : "add"} size={12} color={colors.white} />
      </View>
      <Text style={styles.followPillText}>{isFollowing ? "フォロー中" : "フォローする"}</Text>
    </TouchableOpacity>
  );
};

*** Update File: src/features/tournaments/screens/TournamentsScreen.tsx
@@
-import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
// Firebase Timestamp は使用せず Date を利用
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  Alert,
  Text,
  View,
} from "react-native";

import { supabase } from "@app/config/supabase.config";
import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import {
  TournamentService,
  FirestoreUserService,
} from "@core/services/firestore";
import UserService from "@core/services/userService";
import CreateTournamentModal from "@features/tournaments/components/CreateTournamentModal";
import MemoizedTournamentCard from "@features/tournaments/components/MemoizedTournamentCard";
import VirtualizedList from "@features/tournaments/components/VirtualizedList";
import useTournamentParticipants from "@features/tournaments/hooks/useTournamentParticipants";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import useErrorHandler from "@shared/hooks/useErrorHandler";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import { navigateToUserDetail } from "@shared/utils/navigation";
import ProfileCache from "@core/services/profileCache";

type TournamentsScreenNavigationProp = StackNavigationProp<
  TournamentStackParamList,
  "TournamentsList"
>;

interface Tournament {
  id: string;
  name: string;
  description: string;
  participantCount: number;
  status: "upcoming" | "active" | "completed" | "cancelled";
  isJoined: boolean;
  ownerId: string;
  ownerName: string;
  ownerAvatar?: string;
  recruitmentOpen?: boolean;
  requestPending?: boolean;
}

const TournamentsScreen: React.FC = () => {
  const navigation = useNavigation<TournamentsScreenNavigationProp>();
  const { user } = useAuth();
  const { handleError } = useErrorHandler();
  const [, participantsActions] = useTournamentParticipants();
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [myIds, setMyIds] = useState<Set<string>>(new Set());
  const [profilesUnsub, setProfilesUnsub] = useState<(() => void) | null>(null);
  const [loading, setLoading] = useState(true);
  const [confirm, setConfirm] = useState<{
    visible: boolean;
    title?: string;
    message?: string;
    onConfirm?: () => void;
    loading?: boolean;
  }>({ visible: false });

  // 表示フィルター: すべて / 参加中
  const [filter, setFilter] = useState<"all" | "joined">("all");
  const visibleTournaments = useMemo(
    () => (filter === "joined" ? tournaments.filter((t) => t.isJoined) : tournaments),
    [filter, tournaments],
  );

  // トーナメント一覧の購読
  useEffect(() => {
    if (!user) {
      // 未ログイン時にスピナーが出続けないよう抑止
      setLoading(false);
      return;
    }
    setLoading(true);
    const unsubscribe = TournamentService.subscribeToTournaments(
      (firestoreTournaments) => {
        void (async () => {
          try {
            const currentUserId = await FirestoreUserService.getCurrentUserId();

            // 参加者情報のキャッシュを更新
            const tournamentIds = firestoreTournaments.map((t) => t.id);
            await participantsActions.refreshParticipants(tournamentIds);

            const convertedTournaments: Tournament[] = await Promise.all(
              firestoreTournaments.map(async (tournament) => {
                const participants = participantsActions.getParticipants(
                  tournament.id,
                );
                const isJoined = myIds.has(tournament.ownerId) || participants.some((p) => myIds.has(p.userId));
                const participantCount = participants.some(
                  (p) => p.userId === tournament.ownerId,
                )
                  ? participants.length
                  : participants.length + 1;
                // オーナー情報は Firestore を優先。なければローカルにフォールバック
                let owner = await FirestoreUserService.getUserById(
                  tournament.ownerId,
                );
                if (!owner && tournament.ownerId === currentUserId) {
                  // 現ユーザーの情報をローカルから取得
                  const userService = UserService.getInstance();
                  owner = {
                    displayName:
                      user?.displayName || (await userService.getUserName()),
                    photoURL:
                      user?.avatarUrl || (await userService.getAvatarUrl()),
                  };
                }
                // 参加申請が pending かチェック
                let requestPending = false;
                try {
                  const { data: reqRows, error: reqErr } = await supabase
                    .from("tournament_join_requests")
                    .select("id")
                    .eq("tournamentId", tournament.id)
                    .eq("userId", currentUserId)
                    .eq("status", "pending")
                    .limit(1);
                  if (reqErr) throw reqErr;
                  requestPending = Array.isArray(reqRows) && reqRows.length > 0;
                } catch {
                  /* noop */
                }

                return {
                  id: tournament.id,
                  name: tournament.name,
                  description: tournament.description,
                  participantCount,
                  status: tournament.status,
                  isJoined,
                  ownerId: tournament.ownerId,
                  ownerName: owner?.displayName ?? "ユーザー",
                  ownerAvatar: owner?.photoURL ?? undefined,
                  recruitmentOpen: tournament.recruitmentOpen ?? true,
                  requestPending,
                };
              }),
            );
            setTournaments(convertedTournaments);
            // 作成者のライブな名前/アバターは各カード内（useDisplayProfile）で解決
          } catch (error) {
            handleError(
              error,
              {
                component: "TournamentsScreen",
                action: "loadTournaments",
              },
              {
                fallbackMessage: "トーナメント一覧の取得に失敗しました",
              },
            );
          } finally {
            setLoading(false);
          }
        })();
      },
    );
    return () => {
      unsubscribe();
    };
  }, [user, participantsActions, handleError]);

  const handleJoinTournament = useCallback(
    async (tournamentId: string) => {
      try {
        const t = tournaments.find((x) => x.id === tournamentId);
        if (t && t.ownerId === user?.uid) {
          Alert.alert(
            "トーナメント作成者",
            "あなたが作成したトーナメントには参加できません。",
          );
          return;
        }
        if (t && t.recruitmentOpen === false) {
          Alert.alert("募集停止中", "現在このトーナメントは募集停止中です。");
          return;
        }
        // 参加申請
        await TournamentService.requestJoin(tournamentId);
        // UI のペンディング表示を更新
        setTournaments((prev) =>
          prev.map((t) => {
            if (t.id !== tournamentId) return t;
            if (t.isJoined) return t;
            return { ...t, requestPending: true };
          }),
        );
        Alert.alert(
          "申請しました",
          "参加申請を送信しました。オーナーの承認をお待ちください。",
        );
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "joinTournament",
          },
          {
            fallbackMessage: "トーナメントへの参加申請に失敗しました",
          },
        );
      }
    },
    [tournaments, user?.uid, handleError],
  );

  const handleViewTournament = useCallback(
    (idOrUserKey: string) => {
      if (idOrUserKey.startsWith("user:")) {
        const ownerId = idOrUserKey.replace("user:", "");
        const t = tournaments.find((t) => t.ownerId === ownerId);
        navigateToUserDetail(navigation, ownerId, t?.ownerName, t?.ownerAvatar);
        return;
      }
      navigation.navigate("TournamentRoom", { tournamentId: idOrUserKey });
    },
    [tournaments, navigation],
  );

  const handleCreateTournament = useCallback(
    async (data: { name: string; description: string }) => {
      try {
        const now = new Date();
        const endDate = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30日間
        const tournamentId = await TournamentService.createTournament({
          name: data.name,
          description: data.description,
          ownerId: await FirestoreUserService.getCurrentUserId(),
          // maxParticipants / entryFee / prizePool は未使用のため送らない
          status: "upcoming",
          recruitmentOpen: true,
          startDate: now as any,
          endDate: endDate as any,
        });

        // 作成者を参加者へ追加して UI を更新
        await TournamentService.joinTournament(tournamentId);
        Alert.alert("作成完了", "トーナメントを作成しました。");
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "createTournament",
          },
          {
            fallbackMessage: "トーナメントの作成に失敗しました",
          },
        );
      }
    },
    [handleError],
  );

  const handleToggleRecruitment = useCallback(
    async (id: string, open: boolean) => {
      try {
        await TournamentService.setRecruitmentOpen(id, open);
        setTournaments((prev) =>
          prev.map((t) => (t.id === id ? { ...t, recruitmentOpen: open } : t)),
        );
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "toggleRecruitment",
          },
          {
            fallbackMessage: "募集状態の切り替えに失敗しました",
          },
        );
      }
    },
    [handleError],
  );

  const handleDeleteTournament = useCallback(
    (id: string) => {
      setConfirm({
        visible: true,
        title: "トーナメントを削除",
        message: "この操作は取り消せません。削除しますか？",
        onConfirm: () => {
          void (async () => {
            setConfirm((s) => ({ ...s, loading: true }));
            try {
              await TournamentService.deleteTournament(id);
              setTournaments((prev) => prev.filter((t) => t.id !== id));
            } catch (error) {
              handleError(
                error,
                {
                  component: "TournamentsScreen",
                  action: "deleteTournament",
                },
                {
                  fallbackMessage: "トーナメントの削除に失敗しました",
                },
              );
            } finally {
              setConfirm({ visible: false });
            }
          })();
        },
      });
    },
    [handleError],
  );

  useEffect(() => {
    const ids = new Set<string>();
    if (user?.uid) ids.add(user.uid);
    (async () => {
      try {
        const legacy = await (await import('@core/services/supabase/userService')).FirestoreUserService.getCurrentUserId();
        if (legacy) ids.add(legacy);
      } catch { }
      setMyIds(ids);
    })();
  }, [user?.uid]); const renderTournament = useCallback(
    ({ item }: { item: Tournament }) => (
      <MemoizedTournamentCard
        tournament={item}
        onJoin={(id) => {
          void handleJoinTournament(id);
        }}
        onView={handleViewTournament}
        onToggleRecruitment={(id, open) => {
          void handleToggleRecruitment(id, open);
        }}
        showDelete={myIds.has(item.ownerId)}
        onDelete={(id) => {
          void handleDeleteTournament(id);
        }}
      />
    ),
    [
      handleJoinTournament,
      handleViewTournament,
      handleToggleRecruitment,
      handleDeleteTournament,
      user?.uid,
    ],
  );

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor={colors.backgroundTertiary}
      />

      {/* ヘッダー削除（リクエストにより非表示） */}

      {/* フィルター: 参加中 / すべて */}
      <FilterTabs
        active={filter}
        onChange={(v) => setFilter(v)}
      />

      <VirtualizedList
        data={visibleTournaments}
        renderItem={renderTournament}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.list}
        loading={loading}
        hasMore={false} // 今はページング未対応
        emptyMessage={filter === "joined" ? "参加中のトーナメントがありません" : "トーナメントがありません"}
        itemHeight={200} // カード高さの目安
        maxToRenderPerBatch={5}
        windowSize={10}
        initialNumToRender={10}
      />

      {/* 作成ボタン（アクションボタン） */}
      <TouchableOpacity
        style={styles.fab}
        onPress={() => setShowCreateModal(true)}
      >
        <Ionicons name="add" size={24} color={colors.white} />
      </TouchableOpacity>

      <CreateTournamentModal
        visible={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onCreate={(data) => {
          void handleCreateTournament(data);
        }}
      />
      <ConfirmDialog
        visible={confirm.visible}
        title={confirm.title || ""}
        message={confirm.message}
        confirmText="削除"
        cancelText="キャンセル"
        onConfirm={confirm.onConfirm || (() => setConfirm({ visible: false }))}
        onCancel={() => setConfirm({ visible: false })}
        loading={!!confirm.loading}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: typography.fontWeight.bold,
    color: colors.textPrimary,
    textAlign: "center",
  },
  fab: {
    position: "absolute",
    bottom: spacing.xl,
    right: spacing.xl,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
    ...shadows.lg,
  },
  list: {
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.md,
    paddingBottom: spacing.xl,
  },
});

export default TournamentsScreen;

// 投稿画面と同じデザインのタブ（参加中 / すべて）
const FilterTabs: React.FC<{
  active: "all" | "joined";
  onChange: (v: "all" | "joined") => void;
}> = ({ active, onChange }) => {
  return (
    <SafeAreaView style={{ backgroundColor: colors.backgroundTertiary }}>
      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, active === "joined" && uiStyles.tabActive]}
          onPress={() => onChange("joined")}
        >
          <Text
            style={[uiStyles.tabText, active === "joined" && uiStyles.tabTextActive]}
          >
            参加中
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, active === "all" && uiStyles.tabActive]}
          onPress={() => onChange("all")}
        >
          <Text
            style={[uiStyles.tabText, active === "all" && uiStyles.tabTextActive]}
          >
            すべて
          </Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

+import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { StackNavigationProp } from "@react-navigation/stack";
// Firebase Timestamp は使用せず Date を利用
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  StyleSheet,
  SafeAreaView,
  StatusBar,
  TouchableOpacity,
  Alert,
  Text,
  View,
} from "react-native";

import { supabase } from "@app/config/supabase.config";
import { useAuth } from "@app/contexts/AuthContext";
import type { TournamentStackParamList } from "@app/navigation/TournamentStackNavigator";
import {
  TournamentService,
  FirestoreUserService,
} from "@core/services/firestore";
import UserService from "@core/services/userService";
import CreateTournamentModal from "@features/tournaments/components/CreateTournamentModal";
import MemoizedTournamentCard from "@features/tournaments/components/MemoizedTournamentCard";
import VirtualizedList from "@features/tournaments/components/VirtualizedList";
import useTournamentParticipants from "@features/tournaments/hooks/useTournamentParticipants";
import ConfirmDialog from "@shared/components/ConfirmDialog";
import useErrorHandler from "@shared/hooks/useErrorHandler";
import { colors, spacing, typography, shadows } from "@shared/theme";
import { uiStyles } from "@shared/ui/styles";
import { navigateToUserDetail } from "@shared/utils/navigation";
import ProfileCache from "@core/services/profileCache";

type TournamentsScreenNavigationProp = StackNavigationProp<
  TournamentStackParamList,
  "TournamentsList"
>;

interface Tournament {
  id: string;
  name: string;
  description: string;
  participantCount: number;
  status: "upcoming" | "active" | "completed" | "cancelled";
  isJoined: boolean;
  ownerId: string;
  ownerName: string;
  ownerAvatar?: string;
  recruitmentOpen?: boolean;
  requestPending?: boolean;
}

const TournamentsScreen: React.FC = () => {
  const navigation = useNavigation<TournamentsScreenNavigationProp>();
  const { user } = useAuth();
  const { handleError } = useErrorHandler();
  const [, participantsActions] = useTournamentParticipants();
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [myIds, setMyIds] = useState<Set<string>>(new Set());
  const [profilesUnsub, setProfilesUnsub] = useState<(() => void) | null>(null);
  const [loading, setLoading] = useState(true);
  const [confirm, setConfirm] = useState<{
    visible: boolean;
    title?: string;
    message?: string;
    onConfirm?: () => void;
    loading?: boolean;
  }>({ visible: false });

  // 表示フィルター: すべて / 参加中
  const [filter, setFilter] = useState<"all" | "joined">("all");
  const visibleTournaments = useMemo(
    () => (filter === "joined" ? tournaments.filter((t) => t.isJoined) : tournaments),
    [filter, tournaments],
  );

  // トーナメント一覧の購読
  useEffect(() => {
    if (!user) {
      // 未ログイン時にスピナーが出続けないよう抑止
      setLoading(false);
      return;
    }
    setLoading(true);
    const unsubscribe = TournamentService.subscribeToTournaments(
      (firestoreTournaments) => {
        void (async () => {
          try {
            const currentUserId = await FirestoreUserService.getCurrentUserId();

            // 参加者情報のキャッシュを更新
            const tournamentIds = firestoreTournaments.map((t) => t.id);
            await participantsActions.refreshParticipants(tournamentIds);

            const convertedTournaments: Tournament[] = await Promise.all(
              firestoreTournaments.map(async (tournament) => {
                const participants = participantsActions.getParticipants(
                  tournament.id,
                );
                const isJoined = myIds.has(tournament.ownerId) || participants.some((p) => myIds.has(p.userId));
                const participantCount = participants.some(
                  (p) => p.userId === tournament.ownerId,
                )
                  ? participants.length
                  : participants.length + 1;
                // オーナー情報は Firestore を優先。なければローカルにフォールバック
                let owner = await FirestoreUserService.getUserById(
                  tournament.ownerId,
                );
                if (!owner && tournament.ownerId === currentUserId) {
                  // 現ユーザーの情報をローカルから取得
                  const userService = UserService.getInstance();
                  owner = {
                    displayName:
                      user?.displayName || (await userService.getUserName()),
                    photoURL:
                      user?.avatarUrl || (await userService.getAvatarUrl()),
                  };
                }
                // 参加申請が pending かチェック
                let requestPending = false;
                try {
                  const { data: reqRows, error: reqErr } = await supabase
                    .from("tournament_join_requests")
                    .select("id")
                    .eq("tournamentId", tournament.id)
                    .eq("userId", currentUserId)
                    .eq("status", "pending")
                    .limit(1);
                  if (reqErr) throw reqErr;
                  requestPending = Array.isArray(reqRows) && reqRows.length > 0;
                } catch {
                  /* noop */
                }

                return {
                  id: tournament.id,
                  name: tournament.name,
                  description: tournament.description,
                  participantCount,
                  status: tournament.status,
                  isJoined,
                  ownerId: tournament.ownerId,
                  ownerName: owner?.displayName ?? "ユーザー",
                  ownerAvatar: owner?.photoURL ?? undefined,
                  recruitmentOpen: tournament.recruitmentOpen ?? true,
                  requestPending,
                };
              }),
            );
            setTournaments(convertedTournaments);
            // 作成者のライブな名前/アバターは各カード内（useDisplayProfile）で解決
          } catch (error) {
            handleError(
              error,
              {
                component: "TournamentsScreen",
                action: "loadTournaments",
              },
              {
                fallbackMessage: "トーナメント一覧の取得に失敗しました",
              },
            );
          } finally {
            setLoading(false);
          }
        })();
      },
    );
    return () => {
      unsubscribe();
    };
  }, [user, participantsActions, handleError]);

  const handleJoinTournament = useCallback(
    async (tournamentId: string) => {
      try {
        const t = tournaments.find((x) => x.id === tournamentId);
        if (t && t.ownerId === user?.uid) {
          Alert.alert(
            "トーナメント作成者",
            "あなたが作成したトーナメントには参加できません。",
          );
          return;
        }
        if (t && t.recruitmentOpen === false) {
          Alert.alert("募集停止中", "現在このトーナメントは募集停止中です。");
          return;
        }
        // 参加申請
        await TournamentService.requestJoin(tournamentId);
        // UI のペンディング表示を更新
        setTournaments((prev) =>
          prev.map((t) => {
            if (t.id !== tournamentId) return t;
            if (t.isJoined) return t;
            return { ...t, requestPending: true };
          }),
        );
        Alert.alert(
          "申請しました",
          "参加申請を送信しました。オーナーの承認をお待ちください。",
        );
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "joinTournament",
          },
          {
            fallbackMessage: "トーナメントへの参加申請に失敗しました",
          },
        );
      }
    },
    [tournaments, user?.uid, handleError],
  );

  const handleViewTournament = useCallback(
    (idOrUserKey: string) => {
      if (idOrUserKey.startsWith("user:")) {
        const ownerId = idOrUserKey.replace("user:", "");
        const t = tournaments.find((t) => t.ownerId === ownerId);
        navigateToUserDetail(navigation, ownerId, t?.ownerName, t?.ownerAvatar);
        return;
      }
      navigation.navigate("TournamentRoom", { tournamentId: idOrUserKey });
    },
    [tournaments, navigation],
  );

  const handleCreateTournament = useCallback(
    async (data: { name: string; description: string }) => {
      try {
        const now = new Date();
        const endDate = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30日間
        const tournamentId = await TournamentService.createTournament({
          name: data.name,
          description: data.description,
          ownerId: await FirestoreUserService.getCurrentUserId(),
          // maxParticipants / entryFee / prizePool は未使用のため送らない
          status: "upcoming",
          recruitmentOpen: true,
          startDate: now as any,
          endDate: endDate as any,
        });

        // 作成者を参加者へ追加して UI を更新
        await TournamentService.joinTournament(tournamentId);
        Alert.alert("作成完了", "トーナメントを作成しました。");
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "createTournament",
          },
          {
            fallbackMessage: "トーナメントの作成に失敗しました",
          },
        );
      }
    },
    [handleError],
  );

  const handleToggleRecruitment = useCallback(
    async (id: string, open: boolean) => {
      try {
        await TournamentService.setRecruitmentOpen(id, open);
        setTournaments((prev) =>
          prev.map((t) => (t.id === id ? { ...t, recruitmentOpen: open } : t)),
        );
      } catch (error) {
        handleError(
          error,
          {
            component: "TournamentsScreen",
            action: "toggleRecruitment",
          },
          {
            fallbackMessage: "募集状態の切り替えに失敗しました",
          },
        );
      }
    },
    [handleError],
  );

  const handleDeleteTournament = useCallback(
    (id: string) => {
      setConfirm({
        visible: true,
        title: "トーナメントを削除",
        message: "この操作は取り消せません。削除しますか？",
        onConfirm: () => {
          void (async () => {
            setConfirm((s) => ({ ...s, loading: true }));
            try {
              await TournamentService.deleteTournament(id);
              setTournaments((prev) => prev.filter((t) => t.id !== id));
            } catch (error) {
              handleError(
                error,
                {
                  component: "TournamentsScreen",
                  action: "deleteTournament",
                },
                {
                  fallbackMessage: "トーナメントの削除に失敗しました",
                },
              );
            } finally {
              setConfirm({ visible: false });
            }
          })();
        },
      });
    },
    [handleError],
  );

  useEffect(() => {
    const ids = new Set<string>();
    if (user?.uid) ids.add(user.uid);
    (async () => {
      try {
        const legacy = await (await import('@core/services/supabase/userService')).FirestoreUserService.getCurrentUserId();
        if (legacy) ids.add(legacy);
      } catch { }
      setMyIds(ids);
    })();
  }, [user?.uid]); const renderTournament = useCallback(
    ({ item }: { item: Tournament }) => (
      <MemoizedTournamentCard
        tournament={item}
        onJoin={(id) => {
          void handleJoinTournament(id);
        }}
        onView={handleViewTournament}
        onToggleRecruitment={(id, open) => {
          void handleToggleRecruitment(id, open);
        }}
        showDelete={myIds.has(item.ownerId)}
        onDelete={(id) => {
          void handleDeleteTournament(id);
        }}
      />
    ),
    [
      handleJoinTournament,
      handleViewTournament,
      handleToggleRecruitment,
      handleDeleteTournament,
      user?.uid,
    ],
  );

  return (
    <SafeAreaView style={styles.container}>
      <AppStatusBar />

      {/* ヘッダー削除（リクエストにより非表示） */}

      {/* フィルター: 参加中 / すべて */}
      <FilterTabs
        active={filter}
        onChange={(v) => setFilter(v)}
      />

      <VirtualizedList
        data={visibleTournaments}
        renderItem={renderTournament}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.list}
        loading={loading}
        hasMore={false} // 今はページング未対応
        emptyMessage={filter === "joined" ? "参加中のトーナメントがありません" : "トーナメントがありません"}
        itemHeight={200} // カード高さの目安
        maxToRenderPerBatch={5}
        windowSize={10}
        initialNumToRender={10}
      />

      {/* 作成ボタン（アクションボタン） */}
      <TouchableOpacity
        style={styles.fab}
        onPress={() => setShowCreateModal(true)}
      >
        <Ionicons name="add" size={24} color={colors.white} />
      </TouchableOpacity>

      <CreateTournamentModal
        visible={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onCreate={(data) => {
          void handleCreateTournament(data);
        }}
      />
      <ConfirmDialog
        visible={confirm.visible}
        title={confirm.title || ""}
        message={confirm.message}
        confirmText="削除"
        cancelText="キャンセル"
        onConfirm={confirm.onConfirm || (() => setConfirm({ visible: false }))}
        onCancel={() => setConfirm({ visible: false })}
        loading={!!confirm.loading}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.backgroundTertiary,
  },
  header: {
    paddingHorizontal: spacing.xl,
    paddingVertical: spacing.lg,
    backgroundColor: colors.backgroundPrimary,
    borderBottomWidth: 1,
    borderBottomColor: colors.borderPrimary,
  },
  title: {
    fontSize: typography.fontSize["2xl"],
    fontWeight: typography.fontWeight.bold,
    color: colors.textPrimary,
    textAlign: "center",
  },
  fab: {
    position: "absolute",
    bottom: spacing.xl,
    right: spacing.xl,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.info,
    justifyContent: "center",
    alignItems: "center",
    ...shadows.lg,
  },
  list: {
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.md,
    paddingBottom: spacing.xl,
  },
});

export default TournamentsScreen;

// 投稿画面と同じデザインのタブ（参加中 / すべて）
const FilterTabs: React.FC<{
  active: "all" | "joined";
  onChange: (v: "all" | "joined") => void;
}> = ({ active, onChange }) => {
  return (
    <SafeAreaView style={{ backgroundColor: colors.backgroundTertiary }}>
      <View style={uiStyles.tabBar}>
        <TouchableOpacity
          style={[uiStyles.tab, active === "joined" && uiStyles.tabActive]}
          onPress={() => onChange("joined")}
        >
          <Text
            style={[uiStyles.tabText, active === "joined" && uiStyles.tabTextActive]}
          >
            参加中
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[uiStyles.tab, active === "all" && uiStyles.tabActive]}
          onPress={() => onChange("all")}
        >
          <Text
            style={[uiStyles.tabText, active === "all" && uiStyles.tabTextActive]}
          >
            すべて
          </Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

*** End Patch

